// Code generated by girgen. DO NOT EDIT.

package handy

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #cgo pkg-config: libhandy-1
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <handy.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.hdy_leaflet_transition_type_get_type()), F: marshalLeafletTransitionType},
		{T: externglib.Type(C.hdy_leaflet_get_type()), F: marshalLeafletter},
	})
}

// LeafletTransitionType: this enumeration value describes the possible
// transitions between modes and children in a Leaflet widget.
//
// New values may be added to this enumeration over time.
type LeafletTransitionType int

const (
	// LeafletTransitionTypeOver: cover the old page or uncover the new page,
	// sliding from or towards the end according to orientation, text direction
	// and children order.
	LeafletTransitionTypeOver LeafletTransitionType = iota
	// LeafletTransitionTypeUnder: uncover the new page or cover the old page,
	// sliding from or towards the start according to orientation, text
	// direction and children order.
	LeafletTransitionTypeUnder
	// LeafletTransitionTypeSlide: slide from left, right, up or down according
	// to the orientation, text direction and the children order.
	LeafletTransitionTypeSlide
)

func marshalLeafletTransitionType(p uintptr) (interface{}, error) {
	return LeafletTransitionType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for LeafletTransitionType.
func (l LeafletTransitionType) String() string {
	switch l {
	case LeafletTransitionTypeOver:
		return "Over"
	case LeafletTransitionTypeUnder:
		return "Under"
	case LeafletTransitionTypeSlide:
		return "Slide"
	default:
		return fmt.Sprintf("LeafletTransitionType(%d)", l)
	}
}

type Leaflet struct {
	gtk.Container

	gtk.Orientable
	Swipeable
	*externglib.Object
}

func wrapLeaflet(obj *externglib.Object) *Leaflet {
	return &Leaflet{
		Container: gtk.Container{
			Widget: gtk.Widget{
				InitiallyUnowned: externglib.InitiallyUnowned{
					Object: obj,
				},
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: gtk.Buildable{
					Object: obj,
				},
				Object: obj,
			},
		},
		Orientable: gtk.Orientable{
			Object: obj,
		},
		Swipeable: Swipeable{
			Widget: gtk.Widget{
				InitiallyUnowned: externglib.InitiallyUnowned{
					Object: obj,
				},
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: gtk.Buildable{
					Object: obj,
				},
				Object: obj,
			},
		},
		Object: obj,
	}
}

func marshalLeafletter(p uintptr) (interface{}, error) {
	return wrapLeaflet(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func NewLeaflet() *Leaflet {
	var _cret *C.GtkWidget // in

	_cret = C.hdy_leaflet_new()

	var _leaflet *Leaflet // out

	_leaflet = wrapLeaflet(externglib.Take(unsafe.Pointer(_cret)))

	return _leaflet
}

// AdjacentChild gets the previous or next child that doesn't have 'navigatable'
// child property set to FALSE, or NULL if it doesn't exist. This will be the
// same widget hdy_leaflet_navigate() will navigate to.
//
// The function takes the following parameters:
//
//    - direction: direction.
//
func (self *Leaflet) AdjacentChild(direction NavigationDirection) gtk.Widgetter {
	var _arg0 *C.HdyLeaflet            // out
	var _arg1 C.HdyNavigationDirection // out
	var _cret *C.GtkWidget             // in

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	_arg1 = C.HdyNavigationDirection(direction)

	_cret = C.hdy_leaflet_get_adjacent_child(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(direction)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(gtk.Widgetter)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// CanSwipeBack returns whether the Leaflet allows swiping to the previous
// child.
func (self *Leaflet) CanSwipeBack() bool {
	var _arg0 *C.HdyLeaflet // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_leaflet_get_can_swipe_back(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanSwipeForward returns whether the Leaflet allows swiping to the next child.
func (self *Leaflet) CanSwipeForward() bool {
	var _arg0 *C.HdyLeaflet // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_leaflet_get_can_swipe_forward(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChildByName finds the child of self with the name given as the argument.
// Returns NULL if there is no child with this name.
//
// The function takes the following parameters:
//
//    - name of the child to find.
//
func (self *Leaflet) ChildByName(name string) gtk.Widgetter {
	var _arg0 *C.HdyLeaflet // out
	var _arg1 *C.gchar      // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.hdy_leaflet_get_child_by_name(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(name)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(gtk.Widgetter)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// ChildTransitionDuration returns the amount of time (in milliseconds) that
// transitions between children in self will take.
func (self *Leaflet) ChildTransitionDuration() uint {
	var _arg0 *C.HdyLeaflet // out
	var _cret C.guint       // in

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_leaflet_get_child_transition_duration(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ChildTransitionRunning returns whether self is currently in a transition from
// one page to another.
func (self *Leaflet) ChildTransitionRunning() bool {
	var _arg0 *C.HdyLeaflet // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_leaflet_get_child_transition_running(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Folded gets whether self is folded.
func (self *Leaflet) Folded() bool {
	var _arg0 *C.HdyLeaflet // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_leaflet_get_folded(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Homogeneous gets whether self is homogeneous for the given fold and
// orientation. See hdy_leaflet_set_homogeneous().
//
// The function takes the following parameters:
//
//    - folded: fold.
//    - orientation: orientation.
//
func (self *Leaflet) Homogeneous(folded bool, orientation gtk.Orientation) bool {
	var _arg0 *C.HdyLeaflet    // out
	var _arg1 C.gboolean       // out
	var _arg2 C.GtkOrientation // out
	var _cret C.gboolean       // in

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	if folded {
		_arg1 = C.TRUE
	}
	_arg2 = C.GtkOrientation(orientation)

	_cret = C.hdy_leaflet_get_homogeneous(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(folded)
	runtime.KeepAlive(orientation)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InterpolateSize returns whether the Leaflet is set up to interpolate between
// the sizes of children on page switch.
func (self *Leaflet) InterpolateSize() bool {
	var _arg0 *C.HdyLeaflet // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_leaflet_get_interpolate_size(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ModeTransitionDuration returns the amount of time (in milliseconds) that
// transitions between modes in self will take.
func (self *Leaflet) ModeTransitionDuration() uint {
	var _arg0 *C.HdyLeaflet // out
	var _cret C.guint       // in

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_leaflet_get_mode_transition_duration(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TransitionType gets the type of animation that will be used for transitions
// between modes and children in self.
func (self *Leaflet) TransitionType() LeafletTransitionType {
	var _arg0 *C.HdyLeaflet              // out
	var _cret C.HdyLeafletTransitionType // in

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_leaflet_get_transition_type(_arg0)
	runtime.KeepAlive(self)

	var _leafletTransitionType LeafletTransitionType // out

	_leafletTransitionType = LeafletTransitionType(_cret)

	return _leafletTransitionType
}

// VisibleChild gets the visible child widget.
func (self *Leaflet) VisibleChild() gtk.Widgetter {
	var _arg0 *C.HdyLeaflet // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_leaflet_get_visible_child(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(gtk.Widgetter)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// VisibleChildName gets the name of the currently visible child widget.
func (self *Leaflet) VisibleChildName() string {
	var _arg0 *C.HdyLeaflet // out
	var _cret *C.gchar      // in

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_leaflet_get_visible_child_name(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// InsertChildAfter inserts child in the position after sibling in the list of
// children. If sibling is NULL, insert child at the first position.
//
// The function takes the following parameters:
//
//    - child to insert.
//    - sibling after which to insert child.
//
func (self *Leaflet) InsertChildAfter(child, sibling gtk.Widgetter) {
	var _arg0 *C.HdyLeaflet // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 *C.GtkWidget  // out

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if sibling != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))
	}

	C.hdy_leaflet_insert_child_after(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
	runtime.KeepAlive(sibling)
}

// Navigate switches to the previous or next child that doesn't have
// 'navigatable' child property set to FALSE, similar to performing a swipe
// gesture to go in direction.
//
// The function takes the following parameters:
//
//    - direction: direction.
//
func (self *Leaflet) Navigate(direction NavigationDirection) bool {
	var _arg0 *C.HdyLeaflet            // out
	var _arg1 C.HdyNavigationDirection // out
	var _cret C.gboolean               // in

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	_arg1 = C.HdyNavigationDirection(direction)

	_cret = C.hdy_leaflet_navigate(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Prepend inserts child at the first position in self.
//
// The function takes the following parameters:
//
//    - child to prepend.
//
func (self *Leaflet) Prepend(child gtk.Widgetter) {
	var _arg0 *C.HdyLeaflet // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.hdy_leaflet_prepend(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

// ReorderChildAfter moves child to the position after sibling in the list of
// children. If sibling is NULL, move child to the first position.
//
// The function takes the following parameters:
//
//    - child to move, must be a child of self.
//    - sibling to move child after, or NULL.
//
func (self *Leaflet) ReorderChildAfter(child, sibling gtk.Widgetter) {
	var _arg0 *C.HdyLeaflet // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 *C.GtkWidget  // out

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if sibling != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))
	}

	C.hdy_leaflet_reorder_child_after(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
	runtime.KeepAlive(sibling)
}

// SetCanSwipeBack sets whether or not self allows switching to the previous
// child that has 'navigatable' child property set to TRUE via a swipe gesture.
//
// The function takes the following parameters:
//
//    - canSwipeBack: new value.
//
func (self *Leaflet) SetCanSwipeBack(canSwipeBack bool) {
	var _arg0 *C.HdyLeaflet // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	if canSwipeBack {
		_arg1 = C.TRUE
	}

	C.hdy_leaflet_set_can_swipe_back(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(canSwipeBack)
}

// SetCanSwipeForward sets whether or not self allows switching to the next
// child that has 'navigatable' child property set to TRUE via a swipe gesture.
//
// The function takes the following parameters:
//
//    - canSwipeForward: new value.
//
func (self *Leaflet) SetCanSwipeForward(canSwipeForward bool) {
	var _arg0 *C.HdyLeaflet // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	if canSwipeForward {
		_arg1 = C.TRUE
	}

	C.hdy_leaflet_set_can_swipe_forward(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(canSwipeForward)
}

// SetChildTransitionDuration sets the duration that transitions between
// children in self will take.
//
// The function takes the following parameters:
//
//    - duration: new duration, in milliseconds.
//
func (self *Leaflet) SetChildTransitionDuration(duration uint) {
	var _arg0 *C.HdyLeaflet // out
	var _arg1 C.guint       // out

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	_arg1 = C.guint(duration)

	C.hdy_leaflet_set_child_transition_duration(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(duration)
}

// SetHomogeneous sets the Leaflet to be homogeneous or not for the given fold
// and orientation. If it is homogeneous, the Leaflet will request the same
// width or height for all its children depending on the orientation. If it
// isn't and it is folded, the leaflet may change width or height when a
// different child becomes visible.
//
// The function takes the following parameters:
//
//    - folded: fold.
//    - orientation: orientation.
//    - homogeneous: TRUE to make self homogeneous.
//
func (self *Leaflet) SetHomogeneous(folded bool, orientation gtk.Orientation, homogeneous bool) {
	var _arg0 *C.HdyLeaflet    // out
	var _arg1 C.gboolean       // out
	var _arg2 C.GtkOrientation // out
	var _arg3 C.gboolean       // out

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	if folded {
		_arg1 = C.TRUE
	}
	_arg2 = C.GtkOrientation(orientation)
	if homogeneous {
		_arg3 = C.TRUE
	}

	C.hdy_leaflet_set_homogeneous(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(folded)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(homogeneous)
}

// SetInterpolateSize sets whether or not self will interpolate its size when
// changing the visible child. If the Leaflet:interpolate-size property is set
// to TRUE, self will interpolate its size between the current one and the one
// it'll take after changing the visible child, according to the set transition
// duration.
//
// The function takes the following parameters:
//
//    - interpolateSize: new value.
//
func (self *Leaflet) SetInterpolateSize(interpolateSize bool) {
	var _arg0 *C.HdyLeaflet // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	if interpolateSize {
		_arg1 = C.TRUE
	}

	C.hdy_leaflet_set_interpolate_size(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(interpolateSize)
}

// SetModeTransitionDuration sets the duration that transitions between modes in
// self will take.
//
// The function takes the following parameters:
//
//    - duration: new duration, in milliseconds.
//
func (self *Leaflet) SetModeTransitionDuration(duration uint) {
	var _arg0 *C.HdyLeaflet // out
	var _arg1 C.guint       // out

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	_arg1 = C.guint(duration)

	C.hdy_leaflet_set_mode_transition_duration(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(duration)
}

// SetTransitionType sets the type of animation that will be used for
// transitions between modes and children in self.
//
// The transition type can be changed without problems at runtime, so it is
// possible to change the animation based on the mode or child that is about to
// become current.
//
// The function takes the following parameters:
//
//    - transition: new transition type.
//
func (self *Leaflet) SetTransitionType(transition LeafletTransitionType) {
	var _arg0 *C.HdyLeaflet              // out
	var _arg1 C.HdyLeafletTransitionType // out

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	_arg1 = C.HdyLeafletTransitionType(transition)

	C.hdy_leaflet_set_transition_type(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(transition)
}

// SetVisibleChild makes visible_child visible using a transition determined by
// HdyLeaflet:transition-type and HdyLeaflet:child-transition-duration. The
// transition can be cancelled by the user, in which case visible child will
// change back to the previously visible child.
//
// The function takes the following parameters:
//
//    - visibleChild: new child.
//
func (self *Leaflet) SetVisibleChild(visibleChild gtk.Widgetter) {
	var _arg0 *C.HdyLeaflet // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(visibleChild.Native()))

	C.hdy_leaflet_set_visible_child(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(visibleChild)
}

// SetVisibleChildName makes the child with the name name visible.
//
// See hdy_leaflet_set_visible_child() for more details.
//
// The function takes the following parameters:
//
//    - name of a child.
//
func (self *Leaflet) SetVisibleChildName(name string) {
	var _arg0 *C.HdyLeaflet // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.HdyLeaflet)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.hdy_leaflet_set_visible_child_name(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(name)
}
