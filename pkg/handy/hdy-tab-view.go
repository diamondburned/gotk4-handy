// Code generated by girgen. DO NOT EDIT.

package handy

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <handy.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.hdy_tab_page_get_type()), F: marshalTabPager},
		{T: externglib.Type(C.hdy_tab_view_get_type()), F: marshalTabViewer},
	})
}

type TabPage struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*TabPage)(nil)
)

func wrapTabPage(obj *externglib.Object) *TabPage {
	return &TabPage{
		Object: obj,
	}
}

func marshalTabPager(p uintptr) (interface{}, error) {
	return wrapTabPage(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Child gets the child of self.
//
// The function returns the following values:
//
//    - widget: child of self.
//
func (self *TabPage) Child() gtk.Widgetter {
	var _arg0 *C.HdyTabPage // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_page_get_child(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(gtk.Widgetter)
			return ok
		})
		rv, ok := casted.(gtk.Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// Icon gets the icon of self, see hdy_tab_page_set_icon().
//
// The function returns the following values:
//
//    - icon (optional) of self.
//
func (self *TabPage) Icon() gio.Iconner {
	var _arg0 *C.HdyTabPage // out
	var _cret *C.GIcon      // in

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_page_get_icon(_arg0)
	runtime.KeepAlive(self)

	var _icon gio.Iconner // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(gio.Iconner)
				return ok
			})
			rv, ok := casted.(gio.Iconner)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Iconner")
			}
			_icon = rv
		}
	}

	return _icon
}

// IndicatorActivatable gets whether the indicator of self is activatable, see
// hdy_tab_page_set_indicator_activatable().
//
// The function returns the following values:
//
//    - ok: whether the indicator is activatable.
//
func (self *TabPage) IndicatorActivatable() bool {
	var _arg0 *C.HdyTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_page_get_indicator_activatable(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IndicatorIcon gets the indicator icon of self, see
// hdy_tab_page_set_indicator_icon().
//
// The function returns the following values:
//
//    - icon (optional): indicator icon of self.
//
func (self *TabPage) IndicatorIcon() gio.Iconner {
	var _arg0 *C.HdyTabPage // out
	var _cret *C.GIcon      // in

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_page_get_indicator_icon(_arg0)
	runtime.KeepAlive(self)

	var _icon gio.Iconner // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(gio.Iconner)
				return ok
			})
			rv, ok := casted.(gio.Iconner)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Iconner")
			}
			_icon = rv
		}
	}

	return _icon
}

// Loading gets whether self is loading, see hdy_tab_page_set_loading().
//
// The function returns the following values:
//
//    - ok: whether self is loading.
//
func (self *TabPage) Loading() bool {
	var _arg0 *C.HdyTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_page_get_loading(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NeedsAttention gets whether self needs attention, see
// hdy_tab_page_set_needs_attention().
//
// The function returns the following values:
//
//    - ok: whether self needs attention.
//
func (self *TabPage) NeedsAttention() bool {
	var _arg0 *C.HdyTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_page_get_needs_attention(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Parent gets the parent page of self, or NULL if the self does not have a
// parent.
//
// See hdy_tab_view_add_page() and hdy_tab_view_close_page().
//
// The function returns the following values:
//
//    - tabPage (optional): parent page of self, or NULL.
//
func (self *TabPage) Parent() *TabPage {
	var _arg0 *C.HdyTabPage // out
	var _cret *C.HdyTabPage // in

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_page_get_parent(_arg0)
	runtime.KeepAlive(self)

	var _tabPage *TabPage // out

	if _cret != nil {
		_tabPage = wrapTabPage(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _tabPage
}

// Pinned gets whether self is pinned. See hdy_tab_view_set_page_pinned().
//
// The function returns the following values:
//
//    - ok: whether self is pinned.
//
func (self *TabPage) Pinned() bool {
	var _arg0 *C.HdyTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_page_get_pinned(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Selected gets whether self is selected. See hdy_tab_view_set_selected_page().
//
// The function returns the following values:
//
//    - ok: whether self is selected.
//
func (self *TabPage) Selected() bool {
	var _arg0 *C.HdyTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_page_get_selected(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title gets the title of self, see hdy_tab_page_set_title().
//
// The function returns the following values:
//
//    - utf8 (optional): title of self.
//
func (self *TabPage) Title() string {
	var _arg0 *C.HdyTabPage // out
	var _cret *C.gchar      // in

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_page_get_title(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Tooltip gets the tooltip of self, see hdy_tab_page_set_tooltip().
//
// The function returns the following values:
//
//    - utf8 (optional): tooltip of self.
//
func (self *TabPage) Tooltip() string {
	var _arg0 *C.HdyTabPage // out
	var _cret *C.gchar      // in

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_page_get_tooltip(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// SetIcon sets the icon of self, displayed next to the title.
//
// TabBar will not show the icon if TabPage:loading is set to TRUE, or if self
// is pinned and TabPage:indicator-icon is set.
//
// The function takes the following parameters:
//
//    - icon (optional) of self.
//
func (self *TabPage) SetIcon(icon gio.Iconner) {
	var _arg0 *C.HdyTabPage // out
	var _arg1 *C.GIcon      // out

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))
	if icon != nil {
		_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
	}

	C.hdy_tab_page_set_icon(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(icon)
}

// SetIndicatorActivatable sets whether the indicator of self is activatable.
//
// If set to TRUE, TabView::indicator-activated will be emitted when the
// indicator is clicked.
//
// If TabPage:indicator-icon is not set, does nothing.
//
// The function takes the following parameters:
//
//    - activatable: whether the indicator is activatable.
//
func (self *TabPage) SetIndicatorActivatable(activatable bool) {
	var _arg0 *C.HdyTabPage // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))
	if activatable {
		_arg1 = C.TRUE
	}

	C.hdy_tab_page_set_indicator_activatable(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(activatable)
}

// SetIndicatorIcon sets the indicator icon of self.
//
// A common use case is an audio or camera indicator in a web browser.
//
// TabPage will show it at the beginning of the tab, alongside icon representing
// TabPage:icon or loading spinner.
//
// If the page is pinned, the indicator will be shown instead of icon or
// spinner.
//
// If TabPage:indicator-activatable is set to TRUE, indicator icon can act as a
// button.
//
// The function takes the following parameters:
//
//    - indicatorIcon (optional): indicator icon of self.
//
func (self *TabPage) SetIndicatorIcon(indicatorIcon gio.Iconner) {
	var _arg0 *C.HdyTabPage // out
	var _arg1 *C.GIcon      // out

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))
	if indicatorIcon != nil {
		_arg1 = (*C.GIcon)(unsafe.Pointer(indicatorIcon.Native()))
	}

	C.hdy_tab_page_set_indicator_icon(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(indicatorIcon)
}

// SetLoading sets wether self is loading.
//
// If set to TRUE, TabBar will display a spinner in place of icon.
//
// If self is pinned and TabPage:indicator-icon is set, the loading status will
// not be visible.
//
// The function takes the following parameters:
//
//    - loading: whether self is loading.
//
func (self *TabPage) SetLoading(loading bool) {
	var _arg0 *C.HdyTabPage // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))
	if loading {
		_arg1 = C.TRUE
	}

	C.hdy_tab_page_set_loading(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(loading)
}

// SetNeedsAttention sets whether self needs attention.
//
// TabBar will display a glow under the tab representing self if set to TRUE. If
// the tab is not visible, the corresponding edge of the tab bar will be
// highlighted.
//
// The function takes the following parameters:
//
//    - needsAttention: whether self needs attention.
//
func (self *TabPage) SetNeedsAttention(needsAttention bool) {
	var _arg0 *C.HdyTabPage // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))
	if needsAttention {
		_arg1 = C.TRUE
	}

	C.hdy_tab_page_set_needs_attention(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(needsAttention)
}

// SetTitle sets the title of self.
//
// TabBar will display it in the center of the tab representing self unless it's
// pinned, and will use it as a tooltip unless TabPage:tooltip is set.
//
// The function takes the following parameters:
//
//    - title (optional) of self.
//
func (self *TabPage) SetTitle(title string) {
	var _arg0 *C.HdyTabPage // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))
	if title != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(title)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.hdy_tab_page_set_title(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(title)
}

// SetTooltip sets the tooltip of self, marked up with the Pango text markup
// language.
//
// If not set, TabBar will use TabPage:title as a tooltip instead.
//
// The function takes the following parameters:
//
//    - tooltip (optional) of self.
//
func (self *TabPage) SetTooltip(tooltip string) {
	var _arg0 *C.HdyTabPage // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.HdyTabPage)(unsafe.Pointer(self.Native()))
	if tooltip != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tooltip)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.hdy_tab_page_set_tooltip(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(tooltip)
}

type TabView struct {
	_ [0]func() // equal guard
	gtk.Bin
}

var (
	_ gtk.Binner = (*TabView)(nil)
)

func wrapTabView(obj *externglib.Object) *TabView {
	return &TabView{
		Bin: gtk.Bin{
			Container: gtk.Container{
				Widget: gtk.Widget{
					InitiallyUnowned: externglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: gtk.Buildable{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalTabViewer(p uintptr) (interface{}, error) {
	return wrapTabView(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectClosePage: this signal is emitted after hdy_tab_view_close_page() has
// been called for page.
//
// The handler is expected to call hdy_tab_view_close_page_finish() to confirm
// or reject the closing.
//
// The default handler will immediately confirm closing for non-pinned pages, or
// reject it for pinned pages, equivalent to the following example:
//
//    static gboolean
//    close_page_cb (HdyTabView *view,
//                   HdyTabPage *page,
//                   gpointer    user_data)
//    {
//      hdy_tab_view_close_page_finish (view, page, !hdy_tab_page_get_pinned (page));
//
//      return GDK_EVENT_STOP;
//    }
//
// The hdy_tab_view_close_page_finish() doesn't have to happen during the
// handler, so can be used to do asynchronous checks before confirming the
// closing.
//
// A typical reason to connect to this signal is to show a confirmation dialog
// for closing a tab.
func (self *TabView) ConnectClosePage(f func(page TabPage) bool) externglib.SignalHandle {
	return self.Connect("close-page", f)
}

// ConnectCreateWindow: this signal is emitted when a tab is dropped onto
// desktop and should be transferred into a new window.
//
// The signal handler is expected to create a new window, position it as needed
// and return its TabView that the page will be transferred into.
func (self *TabView) ConnectCreateWindow(f func() TabView) externglib.SignalHandle {
	return self.Connect("create-window", f)
}

// ConnectIndicatorActivated: this signal is emitted after the indicator icon on
// page has been activated.
//
// See TabPage:indicator-icon and TabPage:indicator-activatable.
func (self *TabView) ConnectIndicatorActivated(f func(page TabPage)) externglib.SignalHandle {
	return self.Connect("indicator-activated", f)
}

// ConnectPageAttached: this signal is emitted when a page has been created or
// transferred to self.
//
// A typical reason to connect to this signal would be to connect to page
// signals for things such as updating window title.
func (self *TabView) ConnectPageAttached(f func(page TabPage, position int)) externglib.SignalHandle {
	return self.Connect("page-attached", f)
}

// ConnectPageDetached: this signal is emitted when a page has been removed or
// transferred to another view.
//
// A typical reason to connect to this signal would be to disconnect signal
// handlers connected in the TabView::page-attached handler.
//
// It is important not to try and destroy the page child in the handler of this
// function as the child might merely be moved to another window; use child
// dispose handler for that or do it in sync with your
// hdy_tab_view_close_page_finish() calls.
func (self *TabView) ConnectPageDetached(f func(page TabPage, position int)) externglib.SignalHandle {
	return self.Connect("page-detached", f)
}

// ConnectPageReordered: this signal is emitted after page has been reordered to
// position.
func (self *TabView) ConnectPageReordered(f func(page TabPage, position int)) externglib.SignalHandle {
	return self.Connect("page-reordered", f)
}

// ConnectSetupMenu: this signal is emitted before a context menu is opened for
// page, and after it's closed, in the latter case the page will be set to NULL.
//
// It can be used to set up menu actions before showing the menu, for example
// disable actions not applicable to page.
func (self *TabView) ConnectSetupMenu(f func(page TabPage)) externglib.SignalHandle {
	return self.Connect("setup-menu", f)
}

// NewTabView creates a new TabView widget.
//
// The function returns the following values:
//
//    - tabView: new TabView.
//
func NewTabView() *TabView {
	var _cret *C.HdyTabView // in

	_cret = C.hdy_tab_view_new()

	var _tabView *TabView // out

	_tabView = wrapTabView(externglib.Take(unsafe.Pointer(_cret)))

	return _tabView
}

// AddPage adds child to self with parent as the parent.
//
// This function can be used to automatically position new pages, and to select
// the correct page when this page is closed while being selected (see
// hdy_tab_view_close_page()).
//
// If parent is NULL, this function is equivalent to hdy_tab_view_append().
//
// The function takes the following parameters:
//
//    - child: widget to add.
//    - parent (optional) page for child, or NULL.
//
// The function returns the following values:
//
//    - tabPage: page object representing child.
//
func (self *TabView) AddPage(child gtk.Widgetter, parent *TabPage) *TabPage {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 *C.HdyTabPage // out
	var _cret *C.HdyTabPage // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if parent != nil {
		_arg2 = (*C.HdyTabPage)(unsafe.Pointer(parent.Native()))
	}

	_cret = C.hdy_tab_view_add_page(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
	runtime.KeepAlive(parent)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(externglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// Append inserts child as the last non-pinned page.
//
// The function takes the following parameters:
//
//    - child: widget to add.
//
// The function returns the following values:
//
//    - tabPage: page object representing child.
//
func (self *TabView) Append(child gtk.Widgetter) *TabPage {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.GtkWidget  // out
	var _cret *C.HdyTabPage // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.hdy_tab_view_append(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(externglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// AppendPinned inserts child as the last pinned page.
//
// The function takes the following parameters:
//
//    - child: widget to add.
//
// The function returns the following values:
//
//    - tabPage: page object representing child.
//
func (self *TabView) AppendPinned(child gtk.Widgetter) *TabPage {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.GtkWidget  // out
	var _cret *C.HdyTabPage // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.hdy_tab_view_append_pinned(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(externglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// CloseOtherPages requests to close all pages other than page.
//
// The function takes the following parameters:
//
//    - page of self.
//
func (self *TabView) CloseOtherPages(page *TabPage) {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.HdyTabPage // out

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.HdyTabPage)(unsafe.Pointer(page.Native()))

	C.hdy_tab_view_close_other_pages(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
}

// ClosePage requests to close page.
//
// Calling this function will result in TabView::close-page signal being emitted
// for page. Closing the page can then be confirmed or denied via
// hdy_tab_view_close_page_finish().
//
// If the page is waiting for a hdy_tab_view_close_page_finish() call, this
// function will do nothing.
//
// The default handler for TabView::close-page will immediately confirm closing
// the page if it's non-pinned, or reject it if it's pinned. This behavior can
// be changed by registering your own handler for that signal.
//
// If page was selected, another page will be selected instead:
//
// If the TabPage:parent value is NULL, the next page will be selected when
// possible, or if the page was already last, the previous page will be selected
// instead.
//
// If it's not NULL, the previous page will be selected if it's a descendant
// (possibly indirect) of the parent. If both the previous page and the parent
// are pinned, the parent will be selected instead.
//
// The function takes the following parameters:
//
//    - page of self.
//
func (self *TabView) ClosePage(page *TabPage) {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.HdyTabPage // out

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.HdyTabPage)(unsafe.Pointer(page.Native()))

	C.hdy_tab_view_close_page(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
}

// ClosePageFinish completes a hdy_tab_view_close_page() call for page.
//
// If confirm is TRUE, page will be closed. If it's FALSE, ite will be reverted
// to its previous state and hdy_tab_view_close_page() can be called for it
// again.
//
// This function should not be called unless a custom handler for
// TabView::close-page is used.
//
// The function takes the following parameters:
//
//    - page of self.
//    - confirm: whether to confirm or deny closing page.
//
func (self *TabView) ClosePageFinish(page *TabPage, confirm bool) {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.HdyTabPage // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.HdyTabPage)(unsafe.Pointer(page.Native()))
	if confirm {
		_arg2 = C.TRUE
	}

	C.hdy_tab_view_close_page_finish(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
	runtime.KeepAlive(confirm)
}

// ClosePagesAfter requests to close all pages after page.
//
// The function takes the following parameters:
//
//    - page of self.
//
func (self *TabView) ClosePagesAfter(page *TabPage) {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.HdyTabPage // out

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.HdyTabPage)(unsafe.Pointer(page.Native()))

	C.hdy_tab_view_close_pages_after(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
}

// ClosePagesBefore requests to close all pages before page.
//
// The function takes the following parameters:
//
//    - page of self.
//
func (self *TabView) ClosePagesBefore(page *TabPage) {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.HdyTabPage // out

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.HdyTabPage)(unsafe.Pointer(page.Native()))

	C.hdy_tab_view_close_pages_before(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
}

// DefaultIcon gets default icon of self, see hdy_tab_view_set_default_icon().
//
// The function returns the following values:
//
//    - icon: default icon of self.
//
func (self *TabView) DefaultIcon() gio.Iconner {
	var _arg0 *C.HdyTabView // out
	var _cret *C.GIcon      // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_view_get_default_icon(_arg0)
	runtime.KeepAlive(self)

	var _icon gio.Iconner // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.Iconner is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(gio.Iconner)
			return ok
		})
		rv, ok := casted.(gio.Iconner)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Iconner")
		}
		_icon = rv
	}

	return _icon
}

// IsTransferringPage: whether a page is being transferred.
//
// Gets the value of TabView:is-transferring-page property.
//
// The function returns the following values:
//
//    - ok: whether a page is being transferred.
//
func (self *TabView) IsTransferringPage() bool {
	var _arg0 *C.HdyTabView // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_view_get_is_transferring_page(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MenuModel gets the tab context menu model for self, see
// hdy_tab_view_set_menu_model().
//
// The function returns the following values:
//
//    - menuModel (optional): tab context menu model for self.
//
func (self *TabView) MenuModel() gio.MenuModeller {
	var _arg0 *C.HdyTabView // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_view_get_menu_model(_arg0)
	runtime.KeepAlive(self)

	var _menuModel gio.MenuModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(gio.MenuModeller)
				return ok
			})
			rv, ok := casted.(gio.MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// NPages gets the number of pages in self.
//
// The function returns the following values:
//
//    - gint: number of pages in self.
//
func (self *TabView) NPages() int {
	var _arg0 *C.HdyTabView // out
	var _cret C.gint        // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_view_get_n_pages(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NPinnedPages gets the number of pinned pages in self.
//
// See hdy_tab_view_set_page_pinned().
//
// The function returns the following values:
//
//    - gint: number of pinned pages in self.
//
func (self *TabView) NPinnedPages() int {
	var _arg0 *C.HdyTabView // out
	var _cret C.gint        // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_view_get_n_pinned_pages(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NthPage gets the TabPage representing the child at position.
//
// The function takes the following parameters:
//
//    - position: index of the page in self, starting from 0.
//
// The function returns the following values:
//
//    - tabPage: page object at position.
//
func (self *TabView) NthPage(position int) *TabPage {
	var _arg0 *C.HdyTabView // out
	var _arg1 C.gint        // out
	var _cret *C.HdyTabPage // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = C.gint(position)

	_cret = C.hdy_tab_view_get_nth_page(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(externglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// Page gets the TabPage object representing child.
//
// The function takes the following parameters:
//
//    - child in self.
//
// The function returns the following values:
//
//    - tabPage representing child.
//
func (self *TabView) Page(child gtk.Widgetter) *TabPage {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.GtkWidget  // out
	var _cret *C.HdyTabPage // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.hdy_tab_view_get_page(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(externglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// PagePosition finds the position of page in self, starting from 0.
//
// The function takes the following parameters:
//
//    - page of self.
//
// The function returns the following values:
//
//    - gint: position of page in self.
//
func (self *TabView) PagePosition(page *TabPage) int {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.HdyTabPage // out
	var _cret C.gint        // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.HdyTabPage)(unsafe.Pointer(page.Native()))

	_cret = C.hdy_tab_view_get_page_position(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Pages returns a Model containing the pages of self. This model can be used to
// keep an up to date view of the pages.
//
// The function returns the following values:
//
//    - listModel: model containing pages of self.
//
func (self *TabView) Pages() gio.ListModeller {
	var _arg0 *C.HdyTabView // out
	var _cret *C.GListModel // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_view_get_pages(_arg0)
	runtime.KeepAlive(self)

	var _listModel gio.ListModeller // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.ListModeller is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(gio.ListModeller)
			return ok
		})
		rv, ok := casted.(gio.ListModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.ListModeller")
		}
		_listModel = rv
	}

	return _listModel
}

// SelectedPage gets the currently selected page in self.
//
// The function returns the following values:
//
//    - tabPage (optional): selected page in self.
//
func (self *TabView) SelectedPage() *TabPage {
	var _arg0 *C.HdyTabView // out
	var _cret *C.HdyTabPage // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_view_get_selected_page(_arg0)
	runtime.KeepAlive(self)

	var _tabPage *TabPage // out

	if _cret != nil {
		_tabPage = wrapTabPage(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _tabPage
}

// ShortcutWidget gets the shortcut widget for self, see
// hdy_tab_view_set_shortcut_widget().
//
// The function returns the following values:
//
//    - widget (optional): shortcut widget for self.
//
func (self *TabView) ShortcutWidget() gtk.Widgetter {
	var _arg0 *C.HdyTabView // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_view_get_shortcut_widget(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(gtk.Widgetter)
				return ok
			})
			rv, ok := casted.(gtk.Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Insert inserts a non-pinned page at position.
//
// It's an error to try to insert a page before a pinned page, in that case
// hdy_tab_view_insert_pinned() should be used instead.
//
// The function takes the following parameters:
//
//    - child: widget to add.
//    - position to add child at, starting from 0.
//
// The function returns the following values:
//
//    - tabPage: page object representing child.
//
func (self *TabView) Insert(child gtk.Widgetter, position int) *TabPage {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.gint        // out
	var _cret *C.HdyTabPage // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = C.gint(position)

	_cret = C.hdy_tab_view_insert(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
	runtime.KeepAlive(position)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(externglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// InsertPinned inserts a pinned page at position.
//
// It's an error to try to insert a pinned page after a non-pinned page, in that
// case hdy_tab_view_insert() should be used instead.
//
// The function takes the following parameters:
//
//    - child: widget to add.
//    - position to add child at, starting from 0.
//
// The function returns the following values:
//
//    - tabPage: page object representing child.
//
func (self *TabView) InsertPinned(child gtk.Widgetter, position int) *TabPage {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.gint        // out
	var _cret *C.HdyTabPage // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = C.gint(position)

	_cret = C.hdy_tab_view_insert_pinned(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
	runtime.KeepAlive(position)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(externglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// Prepend inserts child as the first non-pinned page.
//
// The function takes the following parameters:
//
//    - child: widget to add.
//
// The function returns the following values:
//
//    - tabPage: page object representing child.
//
func (self *TabView) Prepend(child gtk.Widgetter) *TabPage {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.GtkWidget  // out
	var _cret *C.HdyTabPage // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.hdy_tab_view_prepend(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(externglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// PrependPinned inserts child as the first pinned page.
//
// The function takes the following parameters:
//
//    - child: widget to add.
//
// The function returns the following values:
//
//    - tabPage: page object representing child.
//
func (self *TabView) PrependPinned(child gtk.Widgetter) *TabPage {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.GtkWidget  // out
	var _cret *C.HdyTabPage // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.hdy_tab_view_prepend_pinned(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(externglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// ReorderBackward reorders page to before its previous page if possible.
//
// The function takes the following parameters:
//
//    - page of self.
//
// The function returns the following values:
//
//    - ok: TRUE if page was moved, FALSE otherwise.
//
func (self *TabView) ReorderBackward(page *TabPage) bool {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.HdyTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.HdyTabPage)(unsafe.Pointer(page.Native()))

	_cret = C.hdy_tab_view_reorder_backward(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReorderFirst reorders page to the first possible position.
//
// The function takes the following parameters:
//
//    - page of self.
//
// The function returns the following values:
//
//    - ok: TRUE if page was moved, FALSE otherwise.
//
func (self *TabView) ReorderFirst(page *TabPage) bool {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.HdyTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.HdyTabPage)(unsafe.Pointer(page.Native()))

	_cret = C.hdy_tab_view_reorder_first(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReorderForward reorders page to after its next page if possible.
//
// The function takes the following parameters:
//
//    - page of self.
//
// The function returns the following values:
//
//    - ok: TRUE if page was moved, FALSE otherwise.
//
func (self *TabView) ReorderForward(page *TabPage) bool {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.HdyTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.HdyTabPage)(unsafe.Pointer(page.Native()))

	_cret = C.hdy_tab_view_reorder_forward(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReorderLast reorders page to the last possible position.
//
// The function takes the following parameters:
//
//    - page of self.
//
// The function returns the following values:
//
//    - ok: TRUE if page was moved, FALSE otherwise.
//
func (self *TabView) ReorderLast(page *TabPage) bool {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.HdyTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.HdyTabPage)(unsafe.Pointer(page.Native()))

	_cret = C.hdy_tab_view_reorder_last(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReorderPage reorders page to position.
//
// It's a programmer error to try to reorder a pinned page after a non-pinned
// one, or a non-pinned page before a pinned one.
//
// The function takes the following parameters:
//
//    - page of self.
//    - position to insert the page at, starting at 0.
//
// The function returns the following values:
//
//    - ok: TRUE if page was moved, FALSE otherwise.
//
func (self *TabView) ReorderPage(page *TabPage, position int) bool {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.HdyTabPage // out
	var _arg2 C.gint        // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.HdyTabPage)(unsafe.Pointer(page.Native()))
	_arg2 = C.gint(position)

	_cret = C.hdy_tab_view_reorder_page(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
	runtime.KeepAlive(position)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectNextPage selects the page after the currently selected page.
//
// If the last page was already selected, this function does nothing.
//
// The function returns the following values:
//
//    - ok: TRUE if the selected page was changed, FALSE otherwise.
//
func (self *TabView) SelectNextPage() bool {
	var _arg0 *C.HdyTabView // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_view_select_next_page(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectPreviousPage selects the page before the currently selected page.
//
// If the first page was already selected, this function does nothing.
//
// The function returns the following values:
//
//    - ok: TRUE if the selected page was changed, FALSE otherwise.
//
func (self *TabView) SelectPreviousPage() bool {
	var _arg0 *C.HdyTabView // out
	var _cret C.gboolean    // in

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_tab_view_select_previous_page(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDefaultIcon sets default page icon for self.
//
// If a page doesn't provide its own icon via TabPage:icon, default icon may be
// used instead for contexts where having an icon is necessary.
//
// TabBar will use default icon for pinned tabs in case the page is not loading,
// doesn't have an icon and an indicator. Default icon is never used for tabs
// that aren't pinned.
//
// By default, 'hdy-tab-icon-missing-symbolic' icon is used.
//
// The function takes the following parameters:
//
//    - defaultIcon: default icon.
//
func (self *TabView) SetDefaultIcon(defaultIcon gio.Iconner) {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.GIcon      // out

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(defaultIcon.Native()))

	C.hdy_tab_view_set_default_icon(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(defaultIcon)
}

// SetMenuModel sets the tab context menu model for self.
//
// When a context menu is shown for a tab, it will be constructed from the
// provided menu model. Use TabView::setup-menu signal to set up the menu
// actions for the particular tab.
//
// The function takes the following parameters:
//
//    - menuModel (optional): menu model.
//
func (self *TabView) SetMenuModel(menuModel gio.MenuModeller) {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	if menuModel != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(menuModel.Native()))
	}

	C.hdy_tab_view_set_menu_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(menuModel)
}

// SetPagePinned pins or unpins page.
//
// Pinned pages are guaranteed to be placed before all non-pinned pages; at any
// given moment the first TabView:n-pinned-pages pages in self are guaranteed to
// be pinned.
//
// When a page is pinned or unpinned, it's automatically reordered: pinning a
// page moves it after other pinned pages; unpinning a page moves it before
// other non-pinned pages.
//
// Pinned pages can still be reordered between each other.
//
// TabBar will display pinned pages in a compact form, never showing the title
// or close button, and only showing a single icon, selected in the following
// order:
//
// 1. TabPage:indicator-icon 2. A spinner if TabPage:loading is TRUE 3.
// TabPage:icon 4. TabView:default-icon
//
// Pinned pages cannot be closed by default, see TabView::close-page for how to
// override that behavior.
//
// The function takes the following parameters:
//
//    - page of self.
//    - pinned: whether page should be pinned.
//
func (self *TabView) SetPagePinned(page *TabPage, pinned bool) {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.HdyTabPage // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.HdyTabPage)(unsafe.Pointer(page.Native()))
	if pinned {
		_arg2 = C.TRUE
	}

	C.hdy_tab_view_set_page_pinned(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
	runtime.KeepAlive(pinned)
}

// SetSelectedPage sets the currently selected page in self.
//
// The function takes the following parameters:
//
//    - selectedPage: page in self.
//
func (self *TabView) SetSelectedPage(selectedPage *TabPage) {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.HdyTabPage // out

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.HdyTabPage)(unsafe.Pointer(selectedPage.Native()))

	C.hdy_tab_view_set_selected_page(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(selectedPage)
}

// SetShortcutWidget sets the shortcut widget for self.
//
// Registers the following shortcuts on widget: * Ctrl+Page Up - switch to the
// previous page * Ctrl+Page Down - switch to the next page * Ctrl+Home - switch
// to the first page * Ctrl+End - switch to the last page * Ctrl+Shift+Page Up -
// move the current page backward * Ctrl+Shift+Page Down - move the current page
// forward * Ctrl+Shift+Home - move the current page at the start *
// Ctrl+Shift+End - move the current page at the end * Ctrl+Tab - switch to the
// next page, with looping * Ctrl+Shift+Tab - switch to the previous page, with
// looping * Alt+1-9 - switch to pages 1-9 * Alt+0 - switch to page 10
//
// These shortcuts are always available on self, this function is useful if they
// should be available globally.
//
// The function takes the following parameters:
//
//    - widget (optional): shortcut widget.
//
func (self *TabView) SetShortcutWidget(widget gtk.Widgetter) {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	if widget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	}

	C.hdy_tab_view_set_shortcut_widget(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(widget)
}

// TransferPage transfers page from self to other_view. The page object will be
// reused.
//
// It's a programmer error to try to insert a pinned page after a non-pinned
// one, or a non-pinned page before a pinned one.
//
// The function takes the following parameters:
//
//    - page of self.
//    - otherView: tab view to transfer the page to.
//    - position to insert the page at, starting at 0.
//
func (self *TabView) TransferPage(page *TabPage, otherView *TabView, position int) {
	var _arg0 *C.HdyTabView // out
	var _arg1 *C.HdyTabPage // out
	var _arg2 *C.HdyTabView // out
	var _arg3 C.gint        // out

	_arg0 = (*C.HdyTabView)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.HdyTabPage)(unsafe.Pointer(page.Native()))
	_arg2 = (*C.HdyTabView)(unsafe.Pointer(otherView.Native()))
	_arg3 = C.gint(position)

	C.hdy_tab_view_transfer_page(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
	runtime.KeepAlive(otherView)
	runtime.KeepAlive(position)
}
