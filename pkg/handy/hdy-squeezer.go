// Code generated by girgen. DO NOT EDIT.

package handy

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <handy.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.hdy_squeezer_transition_type_get_type()), F: marshalSqueezerTransitionType},
		{T: externglib.Type(C.hdy_squeezer_get_type()), F: marshalSqueezerer},
	})
}

// SqueezerTransitionType: these enumeration values describe the possible
// transitions between children in a Squeezer widget.
type SqueezerTransitionType C.gint

const (
	// SqueezerTransitionTypeNone: no transition.
	SqueezerTransitionTypeNone SqueezerTransitionType = iota
	// SqueezerTransitionTypeCrossfade: cross-fade.
	SqueezerTransitionTypeCrossfade
)

func marshalSqueezerTransitionType(p uintptr) (interface{}, error) {
	return SqueezerTransitionType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SqueezerTransitionType.
func (s SqueezerTransitionType) String() string {
	switch s {
	case SqueezerTransitionTypeNone:
		return "None"
	case SqueezerTransitionTypeCrossfade:
		return "Crossfade"
	default:
		return fmt.Sprintf("SqueezerTransitionType(%d)", s)
	}
}

type Squeezer struct {
	_ [0]func() // equal guard
	gtk.Container

	*externglib.Object
	gtk.Orientable
}

var (
	_ gtk.Containerer     = (*Squeezer)(nil)
	_ externglib.Objector = (*Squeezer)(nil)
)

func wrapSqueezer(obj *externglib.Object) *Squeezer {
	return &Squeezer{
		Container: gtk.Container{
			Widget: gtk.Widget{
				InitiallyUnowned: externglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: gtk.Buildable{
					Object: obj,
				},
			},
		},
		Object: obj,
		Orientable: gtk.Orientable{
			Object: obj,
		},
	}
}

func marshalSqueezerer(p uintptr) (interface{}, error) {
	return wrapSqueezer(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSqueezer creates a new Squeezer container.
//
// The function returns the following values:
//
//    - squeezer: new Squeezer.
//
func NewSqueezer() *Squeezer {
	var _cret *C.GtkWidget // in

	_cret = C.hdy_squeezer_new()

	var _squeezer *Squeezer // out

	_squeezer = wrapSqueezer(externglib.Take(unsafe.Pointer(_cret)))

	return _squeezer
}

// ChildEnabled gets whether child is enabled.
//
// See hdy_squeezer_set_child_enabled().
//
// The function takes the following parameters:
//
//    - child of self.
//
// The function returns the following values:
//
//    - ok: TRUE if child is enabled, FALSE otherwise.
//
func (self *Squeezer) ChildEnabled(child gtk.Widgetter) bool {
	var _arg0 *C.HdySqueezer // out
	var _arg1 *C.GtkWidget   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	_cret = C.hdy_squeezer_get_child_enabled(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Homogeneous gets whether self is homogeneous.
//
// See hdy_squeezer_set_homogeneous().
//
// The function returns the following values:
//
//    - ok: TRUE if self is homogeneous, FALSE is not.
//
func (self *Squeezer) Homogeneous() bool {
	var _arg0 *C.HdySqueezer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_squeezer_get_homogeneous(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InterpolateSize gets whether self should interpolate its size on visible
// child change.
//
// See hdy_squeezer_set_interpolate_size().
//
// The function returns the following values:
//
//    - ok: TRUE if self interpolates its size on visible child change, FALSE if
//      not.
//
func (self *Squeezer) InterpolateSize() bool {
	var _arg0 *C.HdySqueezer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_squeezer_get_interpolate_size(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TransitionDuration gets the amount of time (in milliseconds) that transitions
// between children in self will take.
//
// The function returns the following values:
//
//    - guint: transition duration.
//
func (self *Squeezer) TransitionDuration() uint {
	var _arg0 *C.HdySqueezer // out
	var _cret C.guint        // in

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_squeezer_get_transition_duration(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TransitionRunning gets whether self is currently in a transition from one
// child to another.
//
// The function returns the following values:
//
//    - ok: TRUE if the transition is currently running, FALSE otherwise.
//
func (self *Squeezer) TransitionRunning() bool {
	var _arg0 *C.HdySqueezer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_squeezer_get_transition_running(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TransitionType gets the type of animation that will be used for transitions
// between children in self.
//
// The function returns the following values:
//
//    - squeezerTransitionType: current transition type of self.
//
func (self *Squeezer) TransitionType() SqueezerTransitionType {
	var _arg0 *C.HdySqueezer              // out
	var _cret C.HdySqueezerTransitionType // in

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_squeezer_get_transition_type(_arg0)
	runtime.KeepAlive(self)

	var _squeezerTransitionType SqueezerTransitionType // out

	_squeezerTransitionType = SqueezerTransitionType(_cret)

	return _squeezerTransitionType
}

// VisibleChild gets the currently visible child of self, or NULL if there are
// no visible children.
//
// The function returns the following values:
//
//    - widget (optional): visible child of the Squeezer.
//
func (self *Squeezer) VisibleChild() gtk.Widgetter {
	var _arg0 *C.HdySqueezer // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_squeezer_get_visible_child(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(gtk.Widgetter)
				return ok
			})
			rv, ok := casted.(gtk.Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// XAlign gets the Squeezer:xalign property for self.
//
// The function returns the following values:
//
//    - gfloat: xalign property.
//
func (self *Squeezer) XAlign() float32 {
	var _arg0 *C.HdySqueezer // out
	var _cret C.gfloat       // in

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_squeezer_get_xalign(_arg0)
	runtime.KeepAlive(self)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// YAlign gets the Squeezer:yalign property for self.
//
// The function returns the following values:
//
//    - gfloat: yalign property.
//
func (self *Squeezer) YAlign() float32 {
	var _arg0 *C.HdySqueezer // out
	var _cret C.gfloat       // in

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_squeezer_get_yalign(_arg0)
	runtime.KeepAlive(self)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// SetChildEnabled: make self enable or disable child. If a child is disabled,
// it will be ignored when looking for the child fitting the available size
// best. This allows to programmatically and prematurely hide a child of self
// even if it fits in the available space.
//
// This can be used e.g. to ensure a certain child is hidden below a certain
// window width, or any other constraint you find suitable.
//
// The function takes the following parameters:
//
//    - child of self.
//    - enabled: TRUE to enable the child, FALSE to disable it.
//
func (self *Squeezer) SetChildEnabled(child gtk.Widgetter, enabled bool) {
	var _arg0 *C.HdySqueezer // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gboolean     // out

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	if enabled {
		_arg2 = C.TRUE
	}

	C.hdy_squeezer_set_child_enabled(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
	runtime.KeepAlive(enabled)
}

// SetHomogeneous sets self to be homogeneous or not. If it is homogeneous, self
// will request the same size for all its children for its opposite orientation,
// e.g. if self is oriented horizontally and is homogeneous, it will request the
// same height for all its children. If it isn't, self may change size when a
// different child becomes visible.
//
// The function takes the following parameters:
//
//    - homogeneous: TRUE to make self homogeneous.
//
func (self *Squeezer) SetHomogeneous(homogeneous bool) {
	var _arg0 *C.HdySqueezer // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.hdy_squeezer_set_homogeneous(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(homogeneous)
}

// SetInterpolateSize sets whether or not self will interpolate the size of its
// opposing orientation when changing the visible child. If TRUE, self will
// interpolate its size between the one of the previous visible child and the
// one of the new visible child, according to the set transition duration and
// the orientation, e.g. if self is horizontal, it will interpolate the its
// height.
//
// The function takes the following parameters:
//
//    - interpolateSize: TRUE to interpolate the size.
//
func (self *Squeezer) SetInterpolateSize(interpolateSize bool) {
	var _arg0 *C.HdySqueezer // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))
	if interpolateSize {
		_arg1 = C.TRUE
	}

	C.hdy_squeezer_set_interpolate_size(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(interpolateSize)
}

// SetTransitionDuration sets the duration that transitions between children in
// self will take.
//
// The function takes the following parameters:
//
//    - duration: new duration, in milliseconds.
//
func (self *Squeezer) SetTransitionDuration(duration uint) {
	var _arg0 *C.HdySqueezer // out
	var _arg1 C.guint        // out

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))
	_arg1 = C.guint(duration)

	C.hdy_squeezer_set_transition_duration(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(duration)
}

// SetTransitionType sets the type of animation that will be used for
// transitions between children in self. Available types include various kinds
// of fades and slides.
//
// The transition type can be changed without problems at runtime, so it is
// possible to change the animation based on the child that is about to become
// current.
//
// The function takes the following parameters:
//
//    - transition: new transition type.
//
func (self *Squeezer) SetTransitionType(transition SqueezerTransitionType) {
	var _arg0 *C.HdySqueezer              // out
	var _arg1 C.HdySqueezerTransitionType // out

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))
	_arg1 = C.HdySqueezerTransitionType(transition)

	C.hdy_squeezer_set_transition_type(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(transition)
}

// SetXAlign sets the Squeezer:xalign property for self.
//
// The function takes the following parameters:
//
//    - xalign: new xalign value, between 0 and 1.
//
func (self *Squeezer) SetXAlign(xalign float32) {
	var _arg0 *C.HdySqueezer // out
	var _arg1 C.gfloat       // out

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))
	_arg1 = C.gfloat(xalign)

	C.hdy_squeezer_set_xalign(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(xalign)
}

// SetYAlign sets the Squeezer:yalign property for self.
//
// The function takes the following parameters:
//
//    - yalign: new yalign value, between 0 and 1.
//
func (self *Squeezer) SetYAlign(yalign float32) {
	var _arg0 *C.HdySqueezer // out
	var _arg1 C.gfloat       // out

	_arg0 = (*C.HdySqueezer)(unsafe.Pointer(self.Native()))
	_arg1 = C.gfloat(yalign)

	C.hdy_squeezer_set_yalign(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(yalign)
}
