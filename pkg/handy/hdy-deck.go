// Code generated by girgen. DO NOT EDIT.

package handy

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <handy.h>
import "C"

// glib.Type values for hdy-deck.go.
var (
	GTypeDeckTransitionType = externglib.Type(C.hdy_deck_transition_type_get_type())
	GTypeDeck               = externglib.Type(C.hdy_deck_get_type())
)

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeDeckTransitionType, F: marshalDeckTransitionType},
		{T: GTypeDeck, F: marshalDeck},
	})
}

// DeckTransitionType: this enumeration value describes the possible transitions
// between children in a Deck widget.
//
// New values may be added to this enumeration over time.
type DeckTransitionType C.gint

const (
	// DeckTransitionTypeOver: cover the old page or uncover the new page,
	// sliding from or towards the end according to orientation, text direction
	// and children order.
	DeckTransitionTypeOver DeckTransitionType = iota
	// DeckTransitionTypeUnder: uncover the new page or cover the old page,
	// sliding from or towards the start according to orientation, text
	// direction and children order.
	DeckTransitionTypeUnder
	// DeckTransitionTypeSlide: slide from left, right, up or down according to
	// the orientation, text direction and the children order.
	DeckTransitionTypeSlide
)

func marshalDeckTransitionType(p uintptr) (interface{}, error) {
	return DeckTransitionType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DeckTransitionType.
func (d DeckTransitionType) String() string {
	switch d {
	case DeckTransitionTypeOver:
		return "Over"
	case DeckTransitionTypeUnder:
		return "Under"
	case DeckTransitionTypeSlide:
		return "Slide"
	default:
		return fmt.Sprintf("DeckTransitionType(%d)", d)
	}
}

// DeckOverrider contains methods that are overridable.
type DeckOverrider interface {
}

type Deck struct {
	_ [0]func() // equal guard
	gtk.Container

	*externglib.Object
	atk.ImplementorIface
	externglib.InitiallyUnowned
	gtk.Buildable
	gtk.Orientable
	gtk.Widget
	Swipeable
}

var (
	_ gtk.Containerer     = (*Deck)(nil)
	_ externglib.Objector = (*Deck)(nil)
	_ gtk.Widgetter       = (*Deck)(nil)
)

func classInitDecker(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapDeck(obj *externglib.Object) *Deck {
	return &Deck{
		Container: gtk.Container{
			Widget: gtk.Widget{
				InitiallyUnowned: externglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: gtk.Buildable{
					Object: obj,
				},
			},
		},
		Object: obj,
		ImplementorIface: atk.ImplementorIface{
			Object: obj,
		},
		InitiallyUnowned: externglib.InitiallyUnowned{
			Object: obj,
		},
		Buildable: gtk.Buildable{
			Object: obj,
		},
		Orientable: gtk.Orientable{
			Object: obj,
		},
		Widget: gtk.Widget{
			InitiallyUnowned: externglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			ImplementorIface: atk.ImplementorIface{
				Object: obj,
			},
			Buildable: gtk.Buildable{
				Object: obj,
			},
		},
		Swipeable: Swipeable{
			Widget: gtk.Widget{
				InitiallyUnowned: externglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: gtk.Buildable{
					Object: obj,
				},
			},
		},
	}
}

func marshalDeck(p uintptr) (interface{}, error) {
	return wrapDeck(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
func NewDeck() *Deck {
	var _cret *C.GtkWidget // in

	_cret = C.hdy_deck_new()

	var _deck *Deck // out

	_deck = wrapDeck(externglib.Take(unsafe.Pointer(_cret)))

	return _deck
}

// AdjacentChild gets the previous or next child, or NULL if it doesn't exist.
// This will be the same widget hdy_deck_navigate() will navigate to.
//
// The function takes the following parameters:
//
//    - direction: direction.
//
// The function returns the following values:
//
//    - widget (optional) previous or next child, or NULL if it doesn't exist.
//
func (self *Deck) AdjacentChild(direction NavigationDirection) gtk.Widgetter {
	var _arg0 *C.HdyDeck               // out
	var _arg1 C.HdyNavigationDirection // out
	var _cret *C.GtkWidget             // in

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.HdyNavigationDirection(direction)

	_cret = C.hdy_deck_get_adjacent_child(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(direction)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(gtk.Widgetter)
				return ok
			})
			rv, ok := casted.(gtk.Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// CanSwipeBack returns whether the Deck allows swiping to the previous child.
//
// The function returns the following values:
//
//    - ok: TRUE if back swipe is enabled.
//
func (self *Deck) CanSwipeBack() bool {
	var _arg0 *C.HdyDeck // out
	var _cret C.gboolean // in

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_deck_get_can_swipe_back(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanSwipeForward returns whether the Deck allows swiping to the next child.
//
// The function returns the following values:
//
//    - ok: TRUE if forward swipe is enabled.
//
func (self *Deck) CanSwipeForward() bool {
	var _arg0 *C.HdyDeck // out
	var _cret C.gboolean // in

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_deck_get_can_swipe_forward(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChildByName finds the child of self with the name given as the argument.
// Returns NULL if there is no child with this name.
//
// The function takes the following parameters:
//
//    - name of the child to find.
//
// The function returns the following values:
//
//    - widget (optional): requested child of self.
//
func (self *Deck) ChildByName(name string) gtk.Widgetter {
	var _arg0 *C.HdyDeck   // out
	var _arg1 *C.gchar     // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.hdy_deck_get_child_by_name(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(name)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(gtk.Widgetter)
				return ok
			})
			rv, ok := casted.(gtk.Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Homogeneous gets whether self is homogeneous for the given orientation. See
// hdy_deck_set_homogeneous().
//
// The function takes the following parameters:
//
//    - orientation: orientation.
//
// The function returns the following values:
//
//    - ok: whether self is homogeneous for the given orientation.
//
func (self *Deck) Homogeneous(orientation gtk.Orientation) bool {
	var _arg0 *C.HdyDeck       // out
	var _arg1 C.GtkOrientation // out
	var _cret C.gboolean       // in

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.GtkOrientation(orientation)

	_cret = C.hdy_deck_get_homogeneous(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(orientation)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InterpolateSize returns whether the Deck is set up to interpolate between the
// sizes of children on page switch.
//
// The function returns the following values:
//
//    - ok: TRUE if child sizes are interpolated.
//
func (self *Deck) InterpolateSize() bool {
	var _arg0 *C.HdyDeck // out
	var _cret C.gboolean // in

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_deck_get_interpolate_size(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TransitionDuration returns the amount of time (in milliseconds) that
// transitions between children in self will take.
//
// The function returns the following values:
//
//    - guint: child transition duration.
//
func (self *Deck) TransitionDuration() uint {
	var _arg0 *C.HdyDeck // out
	var _cret C.guint    // in

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_deck_get_transition_duration(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TransitionRunning returns whether self is currently in a transition from one
// page to another.
//
// The function returns the following values:
//
//    - ok: TRUE if the transition is currently running, FALSE otherwise.
//
func (self *Deck) TransitionRunning() bool {
	var _arg0 *C.HdyDeck // out
	var _cret C.gboolean // in

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_deck_get_transition_running(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TransitionType gets the type of animation that will be used for transitions
// between children in self.
//
// The function returns the following values:
//
//    - deckTransitionType: current transition type of self.
//
func (self *Deck) TransitionType() DeckTransitionType {
	var _arg0 *C.HdyDeck              // out
	var _cret C.HdyDeckTransitionType // in

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_deck_get_transition_type(_arg0)
	runtime.KeepAlive(self)

	var _deckTransitionType DeckTransitionType // out

	_deckTransitionType = DeckTransitionType(_cret)

	return _deckTransitionType
}

// VisibleChild gets the visible child widget.
//
// The function returns the following values:
//
//    - widget: visible child widget.
//
func (self *Deck) VisibleChild() gtk.Widgetter {
	var _arg0 *C.HdyDeck   // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_deck_get_visible_child(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(gtk.Widgetter)
			return ok
		})
		rv, ok := casted.(gtk.Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// VisibleChildName gets the name of the currently visible child widget.
//
// The function returns the following values:
//
//    - utf8: name of the visible child.
//
func (self *Deck) VisibleChildName() string {
	var _arg0 *C.HdyDeck // out
	var _cret *C.gchar   // in

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_deck_get_visible_child_name(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// InsertChildAfter inserts child in the position after sibling in the list of
// children. If sibling is NULL, insert child at the first position.
//
// The function takes the following parameters:
//
//    - child to insert.
//    - sibling (optional) after which to insert child.
//
func (self *Deck) InsertChildAfter(child, sibling gtk.Widgetter) {
	var _arg0 *C.HdyDeck   // out
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(child).Native()))
	if sibling != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(sibling).Native()))
	}

	C.hdy_deck_insert_child_after(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
	runtime.KeepAlive(sibling)
}

// Navigate switches to the previous or next child, similar to performing a
// swipe gesture to go in direction.
//
// The function takes the following parameters:
//
//    - direction: direction.
//
// The function returns the following values:
//
//    - ok: TRUE if visible child was changed, FALSE otherwise.
//
func (self *Deck) Navigate(direction NavigationDirection) bool {
	var _arg0 *C.HdyDeck               // out
	var _arg1 C.HdyNavigationDirection // out
	var _cret C.gboolean               // in

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.HdyNavigationDirection(direction)

	_cret = C.hdy_deck_navigate(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Prepend inserts child at the first position in self.
//
// The function takes the following parameters:
//
//    - child to prepend.
//
func (self *Deck) Prepend(child gtk.Widgetter) {
	var _arg0 *C.HdyDeck   // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(child).Native()))

	C.hdy_deck_prepend(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

// ReorderChildAfter moves child to the position after sibling in the list of
// children. If sibling is NULL, move child to the first position.
//
// The function takes the following parameters:
//
//    - child to move, must be a child of self.
//    - sibling (optional) to move child after, or NULL.
//
func (self *Deck) ReorderChildAfter(child, sibling gtk.Widgetter) {
	var _arg0 *C.HdyDeck   // out
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(child).Native()))
	if sibling != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(sibling).Native()))
	}

	C.hdy_deck_reorder_child_after(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
	runtime.KeepAlive(sibling)
}

// SetCanSwipeBack sets whether or not self allows switching to the previous
// child via a swipe gesture.
//
// The function takes the following parameters:
//
//    - canSwipeBack: new value.
//
func (self *Deck) SetCanSwipeBack(canSwipeBack bool) {
	var _arg0 *C.HdyDeck // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if canSwipeBack {
		_arg1 = C.TRUE
	}

	C.hdy_deck_set_can_swipe_back(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(canSwipeBack)
}

// SetCanSwipeForward sets whether or not self allows switching to the next
// child via a swipe gesture.
//
// The function takes the following parameters:
//
//    - canSwipeForward: new value.
//
func (self *Deck) SetCanSwipeForward(canSwipeForward bool) {
	var _arg0 *C.HdyDeck // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if canSwipeForward {
		_arg1 = C.TRUE
	}

	C.hdy_deck_set_can_swipe_forward(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(canSwipeForward)
}

// SetHomogeneous sets the Deck to be homogeneous or not for the given
// orientation. If it is homogeneous, the Deck will request the same width or
// height for all its children depending on the orientation. If it isn't, the
// deck may change width or height when a different child becomes visible.
//
// The function takes the following parameters:
//
//    - orientation: orientation.
//    - homogeneous: TRUE to make self homogeneous.
//
func (self *Deck) SetHomogeneous(orientation gtk.Orientation, homogeneous bool) {
	var _arg0 *C.HdyDeck       // out
	var _arg1 C.GtkOrientation // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.GtkOrientation(orientation)
	if homogeneous {
		_arg2 = C.TRUE
	}

	C.hdy_deck_set_homogeneous(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(homogeneous)
}

// SetInterpolateSize sets whether or not self will interpolate its size when
// changing the visible child. If the Deck:interpolate-size property is set to
// TRUE, self will interpolate its size between the current one and the one
// it'll take after changing the visible child, according to the set transition
// duration.
//
// The function takes the following parameters:
//
//    - interpolateSize: new value.
//
func (self *Deck) SetInterpolateSize(interpolateSize bool) {
	var _arg0 *C.HdyDeck // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if interpolateSize {
		_arg1 = C.TRUE
	}

	C.hdy_deck_set_interpolate_size(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(interpolateSize)
}

// SetTransitionDuration sets the duration that transitions between children in
// self will take.
//
// The function takes the following parameters:
//
//    - duration: new duration, in milliseconds.
//
func (self *Deck) SetTransitionDuration(duration uint) {
	var _arg0 *C.HdyDeck // out
	var _arg1 C.guint    // out

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.guint(duration)

	C.hdy_deck_set_transition_duration(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(duration)
}

// SetTransitionType sets the type of animation that will be used for
// transitions between children in self.
//
// The transition type can be changed without problems at runtime, so it is
// possible to change the animation based on the child that is about to become
// current.
//
// The function takes the following parameters:
//
//    - transition: new transition type.
//
func (self *Deck) SetTransitionType(transition DeckTransitionType) {
	var _arg0 *C.HdyDeck              // out
	var _arg1 C.HdyDeckTransitionType // out

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.HdyDeckTransitionType(transition)

	C.hdy_deck_set_transition_type(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(transition)
}

// SetVisibleChild makes visible_child visible using a transition determined by
// HdyDeck:transition-type and HdyDeck:transition-duration. The transition can
// be cancelled by the user, in which case visible child will change back to the
// previously visible child.
//
// The function takes the following parameters:
//
//    - visibleChild: new child.
//
func (self *Deck) SetVisibleChild(visibleChild gtk.Widgetter) {
	var _arg0 *C.HdyDeck   // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(visibleChild).Native()))

	C.hdy_deck_set_visible_child(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(visibleChild)
}

// SetVisibleChildName makes the child with the name name visible.
//
// See hdy_deck_set_visible_child() for more details.
//
// The function takes the following parameters:
//
//    - name of a child.
//
func (self *Deck) SetVisibleChildName(name string) {
	var _arg0 *C.HdyDeck // out
	var _arg1 *C.gchar   // out

	_arg0 = (*C.HdyDeck)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.hdy_deck_set_visible_child_name(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(name)
}
