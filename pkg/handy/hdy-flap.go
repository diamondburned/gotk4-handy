// Code generated by girgen. DO NOT EDIT.

package handy

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <handy.h>
import "C"

// glib.Type values for hdy-flap.go.
var (
	GTypeFlapFoldPolicy     = externglib.Type(C.hdy_flap_fold_policy_get_type())
	GTypeFlapTransitionType = externglib.Type(C.hdy_flap_transition_type_get_type())
	GTypeFlap               = externglib.Type(C.hdy_flap_get_type())
)

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeFlapFoldPolicy, F: marshalFlapFoldPolicy},
		{T: GTypeFlapTransitionType, F: marshalFlapTransitionType},
		{T: GTypeFlap, F: marshalFlap},
	})
}

// FlapFoldPolicy: these enumeration values describe the possible folding
// behavior in a Flap widget.
type FlapFoldPolicy C.gint

const (
	// FlapFoldPolicyNever: disable folding, the flap cannot reach narrow sizes.
	FlapFoldPolicyNever FlapFoldPolicy = iota
	// FlapFoldPolicyAlways: keep the flap always folded.
	FlapFoldPolicyAlways
	// FlapFoldPolicyAuto: fold and unfold the flap based on available space.
	FlapFoldPolicyAuto
)

func marshalFlapFoldPolicy(p uintptr) (interface{}, error) {
	return FlapFoldPolicy(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FlapFoldPolicy.
func (f FlapFoldPolicy) String() string {
	switch f {
	case FlapFoldPolicyNever:
		return "Never"
	case FlapFoldPolicyAlways:
		return "Always"
	case FlapFoldPolicyAuto:
		return "Auto"
	default:
		return fmt.Sprintf("FlapFoldPolicy(%d)", f)
	}
}

// FlapTransitionType: these enumeration values describe the possible
// transitions between children in a Flap widget, as well as which areas can be
// swiped via Flap:swipe-to-open and Flap:swipe-to-close.
//
// New values may be added to this enum over time.
type FlapTransitionType C.gint

const (
	// FlapTransitionTypeOver: flap slides over the content, which is dimmed.
	// When folded, only the flap can be swiped.
	FlapTransitionTypeOver FlapTransitionType = iota
	// FlapTransitionTypeUnder: content slides over the flap. Only the content
	// can be swiped.
	FlapTransitionTypeUnder
	// FlapTransitionTypeSlide: flap slides offscreen when hidden, neither the
	// flap nor content overlap each other. Both widgets can be swiped.
	FlapTransitionTypeSlide
)

func marshalFlapTransitionType(p uintptr) (interface{}, error) {
	return FlapTransitionType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FlapTransitionType.
func (f FlapTransitionType) String() string {
	switch f {
	case FlapTransitionTypeOver:
		return "Over"
	case FlapTransitionTypeUnder:
		return "Under"
	case FlapTransitionTypeSlide:
		return "Slide"
	default:
		return fmt.Sprintf("FlapTransitionType(%d)", f)
	}
}

// FlapOverrider contains methods that are overridable.
type FlapOverrider interface {
}

type Flap struct {
	_ [0]func() // equal guard
	gtk.Container

	*externglib.Object
	atk.ImplementorIface
	externglib.InitiallyUnowned
	gtk.Buildable
	gtk.Orientable
	gtk.Widget
	Swipeable
}

var (
	_ gtk.Containerer     = (*Flap)(nil)
	_ externglib.Objector = (*Flap)(nil)
	_ gtk.Widgetter       = (*Flap)(nil)
)

func classInitFlapper(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapFlap(obj *externglib.Object) *Flap {
	return &Flap{
		Container: gtk.Container{
			Widget: gtk.Widget{
				InitiallyUnowned: externglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: gtk.Buildable{
					Object: obj,
				},
			},
		},
		Object: obj,
		ImplementorIface: atk.ImplementorIface{
			Object: obj,
		},
		InitiallyUnowned: externglib.InitiallyUnowned{
			Object: obj,
		},
		Buildable: gtk.Buildable{
			Object: obj,
		},
		Orientable: gtk.Orientable{
			Object: obj,
		},
		Widget: gtk.Widget{
			InitiallyUnowned: externglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			ImplementorIface: atk.ImplementorIface{
				Object: obj,
			},
			Buildable: gtk.Buildable{
				Object: obj,
			},
		},
		Swipeable: Swipeable{
			Widget: gtk.Widget{
				InitiallyUnowned: externglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: gtk.Buildable{
					Object: obj,
				},
			},
		},
	}
}

func marshalFlap(p uintptr) (interface{}, error) {
	return wrapFlap(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFlap creates a new Flap.
//
// The function returns the following values:
//
//    - flap: new Flap.
//
func NewFlap() *Flap {
	var _cret *C.GtkWidget // in

	_cret = C.hdy_flap_new()

	var _flap *Flap // out

	_flap = wrapFlap(externglib.Take(unsafe.Pointer(_cret)))

	return _flap
}

// Content gets the content widget for self.
//
// The function returns the following values:
//
//    - widget (optional): content widget for self.
//
func (self *Flap) Content() gtk.Widgetter {
	var _arg0 *C.HdyFlap   // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_flap_get_content(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(gtk.Widgetter)
				return ok
			})
			rv, ok := casted.(gtk.Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Flap gets the flap widget for self.
//
// The function returns the following values:
//
//    - widget (optional): flap widget for self.
//
func (self *Flap) Flap() gtk.Widgetter {
	var _arg0 *C.HdyFlap   // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_flap_get_flap(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(gtk.Widgetter)
				return ok
			})
			rv, ok := casted.(gtk.Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// FlapPosition gets the flap position for self.
//
// The function returns the following values:
//
//    - packType: flap position for self.
//
func (self *Flap) FlapPosition() gtk.PackType {
	var _arg0 *C.HdyFlap    // out
	var _cret C.GtkPackType // in

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_flap_get_flap_position(_arg0)
	runtime.KeepAlive(self)

	var _packType gtk.PackType // out

	_packType = gtk.PackType(_cret)

	return _packType
}

// FoldDuration returns the amount of time (in milliseconds) that fold
// transitions in self will take.
//
// The function returns the following values:
//
//    - guint: fold transition duration.
//
func (self *Flap) FoldDuration() uint {
	var _arg0 *C.HdyFlap // out
	var _cret C.guint    // in

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_flap_get_fold_duration(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// FoldPolicy gets the current fold policy of self. See
// hdy_flap_set_fold_policy().
//
// The function returns the following values:
//
//    - flapFoldPolicy: current fold policy of self.
//
func (self *Flap) FoldPolicy() FlapFoldPolicy {
	var _arg0 *C.HdyFlap          // out
	var _cret C.HdyFlapFoldPolicy // in

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_flap_get_fold_policy(_arg0)
	runtime.KeepAlive(self)

	var _flapFoldPolicy FlapFoldPolicy // out

	_flapFoldPolicy = FlapFoldPolicy(_cret)

	return _flapFoldPolicy
}

// Folded gets whether self is currently folded.
//
// See Flap:fold-policy.
//
// The function returns the following values:
//
//    - ok: TRUE if self is currently folded, FALSE otherwise.
//
func (self *Flap) Folded() bool {
	var _arg0 *C.HdyFlap // out
	var _cret C.gboolean // in

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_flap_get_folded(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Locked gets whether self is locked.
//
// The function returns the following values:
//
//    - ok: TRUE if self is locked, FALSE otherwise.
//
func (self *Flap) Locked() bool {
	var _arg0 *C.HdyFlap // out
	var _cret C.gboolean // in

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_flap_get_locked(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Modal gets whether the self is modal. See hdy_flap_set_modal().
//
// The function returns the following values:
//
//    - ok: TRUE if self is modal.
//
func (self *Flap) Modal() bool {
	var _arg0 *C.HdyFlap // out
	var _cret C.gboolean // in

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_flap_get_modal(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RevealDuration returns the amount of time (in milliseconds) that reveal
// transitions in self will take.
//
// The function returns the following values:
//
//    - guint: reveal transition duration.
//
func (self *Flap) RevealDuration() uint {
	var _arg0 *C.HdyFlap // out
	var _cret C.guint    // in

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_flap_get_reveal_duration(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// RevealFlap gets whether the flap widget is revealed for self.
//
// The function returns the following values:
//
//    - ok: TRUE if the flap widget is revealed, FALSE otherwise.
//
func (self *Flap) RevealFlap() bool {
	var _arg0 *C.HdyFlap // out
	var _cret C.gboolean // in

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_flap_get_reveal_flap(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RevealProgress gets the current reveal transition progress for self. 0 means
// fully hidden, 1 means fully revealed. See Flap:reveal-flap.
//
// The function returns the following values:
//
//    - gdouble: current reveal progress for self.
//
func (self *Flap) RevealProgress() float64 {
	var _arg0 *C.HdyFlap // out
	var _cret C.gdouble  // in

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_flap_get_reveal_progress(_arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Separator gets the separator widget for self.
//
// The function returns the following values:
//
//    - widget (optional): separator widget for self.
//
func (self *Flap) Separator() gtk.Widgetter {
	var _arg0 *C.HdyFlap   // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_flap_get_separator(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(gtk.Widgetter)
				return ok
			})
			rv, ok := casted.(gtk.Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// SwipeToClose gets whether self can be closed with a swipe gesture.
//
// The function returns the following values:
//
//    - ok: TRUE if self can be closed with a swipe gesture.
//
func (self *Flap) SwipeToClose() bool {
	var _arg0 *C.HdyFlap // out
	var _cret C.gboolean // in

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_flap_get_swipe_to_close(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SwipeToOpen gets whether self can be opened with a swipe gesture.
//
// The function returns the following values:
//
//    - ok: TRUE if self can be opened with a swipe gesture.
//
func (self *Flap) SwipeToOpen() bool {
	var _arg0 *C.HdyFlap // out
	var _cret C.gboolean // in

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_flap_get_swipe_to_open(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TransitionType gets the type of animation that will be used for reveal and
// fold transitions in self.
//
// The function returns the following values:
//
//    - flapTransitionType: current transition type of self.
//
func (self *Flap) TransitionType() FlapTransitionType {
	var _arg0 *C.HdyFlap              // out
	var _cret C.HdyFlapTransitionType // in

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_flap_get_transition_type(_arg0)
	runtime.KeepAlive(self)

	var _flapTransitionType FlapTransitionType // out

	_flapTransitionType = FlapTransitionType(_cret)

	return _flapTransitionType
}

// SetContent sets the content widget for self, always displayed when unfolded,
// and partially visible when folded.
//
// The function takes the following parameters:
//
//    - content (optional) widget, or NULL.
//
func (self *Flap) SetContent(content gtk.Widgetter) {
	var _arg0 *C.HdyFlap   // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if content != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(content).Native()))
	}

	C.hdy_flap_set_content(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(content)
}

// SetFlap sets the flap widget for self, only visible when Flap:reveal-progress
// is greater than 0.
//
// The function takes the following parameters:
//
//    - flap (optional) widget, or NULL.
//
func (self *Flap) SetFlap(flap gtk.Widgetter) {
	var _arg0 *C.HdyFlap   // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if flap != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(flap).Native()))
	}

	C.hdy_flap_set_flap(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(flap)
}

// SetFlapPosition sets the flap position for self. If GTK_PACK_START, the flap
// is displayed before the content, if GTK_PACK_END, it's displayed after the
// content.
//
// The function takes the following parameters:
//
//    - position: new value.
//
func (self *Flap) SetFlapPosition(position gtk.PackType) {
	var _arg0 *C.HdyFlap    // out
	var _arg1 C.GtkPackType // out

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.GtkPackType(position)

	C.hdy_flap_set_flap_position(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)
}

// SetFoldDuration sets the duration that fold transitions in self will take.
//
// The function takes the following parameters:
//
//    - duration: new duration, in milliseconds.
//
func (self *Flap) SetFoldDuration(duration uint) {
	var _arg0 *C.HdyFlap // out
	var _arg1 C.guint    // out

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.guint(duration)

	C.hdy_flap_set_fold_duration(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(duration)
}

// SetFoldPolicy sets the current fold policy for self. See FlapFoldPolicy for
// available policies.
//
// The function takes the following parameters:
//
//    - policy: fold policy.
//
func (self *Flap) SetFoldPolicy(policy FlapFoldPolicy) {
	var _arg0 *C.HdyFlap          // out
	var _arg1 C.HdyFlapFoldPolicy // out

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.HdyFlapFoldPolicy(policy)

	C.hdy_flap_set_fold_policy(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(policy)
}

// SetLocked sets whether self is locked.
//
// If FALSE, folding self when the flap is revealed automatically closes it, and
// unfolding it when the flap is not revealed opens it. If TRUE,
// Flap:reveal-flap value never changes on its own.
//
// The function takes the following parameters:
//
//    - locked: new value.
//
func (self *Flap) SetLocked(locked bool) {
	var _arg0 *C.HdyFlap // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if locked {
		_arg1 = C.TRUE
	}

	C.hdy_flap_set_locked(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(locked)
}

// SetModal sets whether the self can be closed with a click.
//
// If modal is TRUE, clicking the content widget while flap is revealed, or
// pressing Escape key, will close the flap. If FALSE, clicks are passed through
// to the content widget.
//
// The function takes the following parameters:
//
//    - modal: whether self can be closed with a click.
//
func (self *Flap) SetModal(modal bool) {
	var _arg0 *C.HdyFlap // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.hdy_flap_set_modal(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(modal)
}

// SetRevealDuration sets the duration that reveal transitions in self will
// take.
//
// The function takes the following parameters:
//
//    - duration: new duration, in milliseconds.
//
func (self *Flap) SetRevealDuration(duration uint) {
	var _arg0 *C.HdyFlap // out
	var _arg1 C.guint    // out

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.guint(duration)

	C.hdy_flap_set_reveal_duration(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(duration)
}

// SetRevealFlap sets whether the flap widget is revealed for self.
//
// The function takes the following parameters:
//
//    - revealFlap: TRUE to reveal the flap widget, FALSE otherwise.
//
func (self *Flap) SetRevealFlap(revealFlap bool) {
	var _arg0 *C.HdyFlap // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if revealFlap {
		_arg1 = C.TRUE
	}

	C.hdy_flap_set_reveal_flap(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(revealFlap)
}

// SetSeparator sets the separator widget for self, displayed between content
// and flap when there's no shadow to display. When exactly it's visible depends
// on the Flap:transition-type value. If NULL, no separator will be used.
//
// The function takes the following parameters:
//
//    - separator (optional) widget, or NULL.
//
func (self *Flap) SetSeparator(separator gtk.Widgetter) {
	var _arg0 *C.HdyFlap   // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if separator != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(separator).Native()))
	}

	C.hdy_flap_set_separator(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(separator)
}

// SetSwipeToClose sets whether self can be closed with a swipe gesture.
//
// The area that can be swiped depends on the Flap:transition-type value.
//
// The function takes the following parameters:
//
//    - swipeToClose: whether self can be closed with a swipe gesture.
//
func (self *Flap) SetSwipeToClose(swipeToClose bool) {
	var _arg0 *C.HdyFlap // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if swipeToClose {
		_arg1 = C.TRUE
	}

	C.hdy_flap_set_swipe_to_close(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(swipeToClose)
}

// SetSwipeToOpen sets whether self can be opened with a swipe gesture.
//
// The area that can be swiped depends on the Flap:transition-type value.
//
// The function takes the following parameters:
//
//    - swipeToOpen: whether self can be opened with a swipe gesture.
//
func (self *Flap) SetSwipeToOpen(swipeToOpen bool) {
	var _arg0 *C.HdyFlap // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if swipeToOpen {
		_arg1 = C.TRUE
	}

	C.hdy_flap_set_swipe_to_open(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(swipeToOpen)
}

// SetTransitionType sets the type of animation that will be used for reveal and
// fold transitions in self.
//
// Flap:flap is transparent by default, which means the content will be seen
// through it with HDY_FLAP_TRANSITION_TYPE_OVER transitions; add the
// .background style class to it if this is unwanted.
//
// The function takes the following parameters:
//
//    - transitionType: new transition type.
//
func (self *Flap) SetTransitionType(transitionType FlapTransitionType) {
	var _arg0 *C.HdyFlap              // out
	var _arg1 C.HdyFlapTransitionType // out

	_arg0 = (*C.HdyFlap)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.HdyFlapTransitionType(transitionType)

	C.hdy_flap_set_transition_type(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(transitionType)
}
