// Code generated by girgen. DO NOT EDIT.

package handy

import (
	"runtime"
	"runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <handy.h>
// extern GtkWidget* _gotk4_gtk3_ListBoxCreateWidgetFunc(gpointer, gpointer);
// extern gchar* _gotk4_handy1_ComboRowGetEnumValueNameFunc(HdyEnumValueObject*, gpointer);
// extern gchar* _gotk4_handy1_ComboRowGetNameFunc(gpointer, gpointer);
// extern void callbackDelete(gpointer);
import "C"

// glib.Type values for hdy-combo-row.go.
var GTypeComboRow = externglib.Type(C.hdy_combo_row_get_type())

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeComboRow, F: marshalComboRow},
	})
}

// ComboRowGetEnumValueNameFunc: called for combo rows that are bound to an
// enumeration with hdy_combo_row_set_for_enum() for each value from that
// enumeration.
type ComboRowGetEnumValueNameFunc func(value *EnumValueObject) (utf8 string)

//export _gotk4_handy1_ComboRowGetEnumValueNameFunc
func _gotk4_handy1_ComboRowGetEnumValueNameFunc(arg1 *C.HdyEnumValueObject, arg2 C.gpointer) (cret *C.gchar) {
	var fn ComboRowGetEnumValueNameFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ComboRowGetEnumValueNameFunc)
	}

	var _value *EnumValueObject // out

	_value = wrapEnumValueObject(externglib.Take(unsafe.Pointer(arg1)))

	utf8 := fn(_value)

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

// ComboRowGetNameFunc: called for combo rows that are bound to a Model with
// hdy_combo_row_bind_name_model() for each item that gets added to the model.
type ComboRowGetNameFunc func(item *externglib.Object) (utf8 string)

//export _gotk4_handy1_ComboRowGetNameFunc
func _gotk4_handy1_ComboRowGetNameFunc(arg1 C.gpointer, arg2 C.gpointer) (cret *C.gchar) {
	var fn ComboRowGetNameFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ComboRowGetNameFunc)
	}

	var _item *externglib.Object // out

	_item = externglib.Take(unsafe.Pointer(arg1))

	utf8 := fn(_item)

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

// EnumValueRowName: this is a default implementation of
// ComboRowGetEnumValueNameFunc to be used with hdy_combo_row_set_for_enum(). If
// the enumeration has a nickname, it will return it, otherwise it will return
// its name.
//
// The function takes the following parameters:
//
//    - value from the enum from which to get a name.
//    - userData (optional): unused user data.
//
// The function returns the following values:
//
//    - utf8: newly allocated displayable name that represents value.
//
func EnumValueRowName(value *EnumValueObject, userData cgo.Handle) string {
	var _arg1 *C.HdyEnumValueObject // out
	var _arg2 C.gpointer            // out
	var _cret *C.gchar              // in

	_arg1 = (*C.HdyEnumValueObject)(unsafe.Pointer(externglib.InternObject(value).Native()))
	_arg2 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.hdy_enum_value_row_name(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(userData)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ComboRowOverrider contains methods that are overridable.
type ComboRowOverrider interface {
}

type ComboRow struct {
	_ [0]func() // equal guard
	ActionRow
}

var (
	_ gtk.Binner          = (*ComboRow)(nil)
	_ externglib.Objector = (*ComboRow)(nil)
)

func classInitComboRower(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapComboRow(obj *externglib.Object) *ComboRow {
	return &ComboRow{
		ActionRow: ActionRow{
			PreferencesRow: PreferencesRow{
				ListBoxRow: gtk.ListBoxRow{
					Bin: gtk.Bin{
						Container: gtk.Container{
							Widget: gtk.Widget{
								InitiallyUnowned: externglib.InitiallyUnowned{
									Object: obj,
								},
								Object: obj,
								ImplementorIface: atk.ImplementorIface{
									Object: obj,
								},
								Buildable: gtk.Buildable{
									Object: obj,
								},
							},
						},
					},
					Object: obj,
					Actionable: gtk.Actionable{
						Widget: gtk.Widget{
							InitiallyUnowned: externglib.InitiallyUnowned{
								Object: obj,
							},
							Object: obj,
							ImplementorIface: atk.ImplementorIface{
								Object: obj,
							},
							Buildable: gtk.Buildable{
								Object: obj,
							},
						},
					},
				},
			},
		},
	}
}

func marshalComboRow(p uintptr) (interface{}, error) {
	return wrapComboRow(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewComboRow creates a new ComboRow.
//
// The function returns the following values:
//
//    - comboRow: new ComboRow.
//
func NewComboRow() *ComboRow {
	var _cret *C.GtkWidget // in

	_cret = C.hdy_combo_row_new()

	var _comboRow *ComboRow // out

	_comboRow = wrapComboRow(externglib.Take(unsafe.Pointer(_cret)))

	return _comboRow
}

// BindModel binds model to self.
//
// If self was already bound to a model, that previous binding is destroyed.
//
// The contents of self are cleared and then filled with widgets that represent
// items from model. self is updated whenever model changes. If model is NULL,
// self is left empty.
//
// The function takes the following parameters:
//
//    - model (optional) to be bound to self.
//    - createListWidgetFunc (optional): function that creates widgets for items
//      to display in the list, or NULL in case you also passed NULL as model.
//    - createCurrentWidgetFunc (optional): function that creates widgets for
//      items to display as the selected item, or NULL in case you also passed
//      NULL as model.
//
func (self *ComboRow) BindModel(model gio.ListModeller, createListWidgetFunc, createCurrentWidgetFunc gtk.ListBoxCreateWidgetFunc) {
	var _arg0 *C.HdyComboRow               // out
	var _arg1 *C.GListModel                // out
	var _arg2 C.GtkListBoxCreateWidgetFunc // out
	var _arg3 C.GtkListBoxCreateWidgetFunc // out
	var _arg4 C.gpointer
	var _arg5 C.GDestroyNotify

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(externglib.InternObject(model).Native()))
	}
	if createListWidgetFunc != nil {
	}
	if createCurrentWidgetFunc != nil {
		_arg3 = (*[0]byte)(C._gotk4_gtk3_ListBoxCreateWidgetFunc)
		_arg4 = C.gpointer(gbox.Assign(createCurrentWidgetFunc))
		_arg5 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.hdy_combo_row_bind_model(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
	runtime.KeepAlive(createListWidgetFunc)
	runtime.KeepAlive(createCurrentWidgetFunc)
}

// BindNameModel binds model to self.
//
// If self was already bound to a model, that previous binding is destroyed.
//
// The contents of self are cleared and then filled with widgets that represent
// items from model. self is updated whenever model changes. If model is NULL,
// self is left empty.
//
// This is more convenient to use than hdy_combo_row_bind_model() if you want to
// represent items of the model with names.
//
// The function takes the following parameters:
//
//    - model (optional) to be bound to self.
//    - getNameFunc (optional): function that creates names for items, or NULL in
//      case you also passed NULL as model.
//
func (self *ComboRow) BindNameModel(model gio.ListModeller, getNameFunc ComboRowGetNameFunc) {
	var _arg0 *C.HdyComboRow           // out
	var _arg1 *C.GListModel            // out
	var _arg2 C.HdyComboRowGetNameFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(externglib.InternObject(model).Native()))
	}
	if getNameFunc != nil {
		_arg2 = (*[0]byte)(C._gotk4_handy1_ComboRowGetNameFunc)
		_arg3 = C.gpointer(gbox.Assign(getNameFunc))
		_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.hdy_combo_row_bind_name_model(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
	runtime.KeepAlive(getNameFunc)
}

// Model gets the model bound to self, or NULL if none is bound.
//
// The function returns the following values:
//
//    - listModel (optional) bound to self or NULL.
//
func (self *ComboRow) Model() *gio.ListModel {
	var _arg0 *C.HdyComboRow // out
	var _cret *C.GListModel  // in

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_combo_row_get_model(_arg0)
	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	if _cret != nil {
		{
			obj := externglib.Take(unsafe.Pointer(_cret))
			_listModel = &gio.ListModel{
				Object: obj,
			}
		}
	}

	return _listModel
}

// SelectedIndex gets the index of the selected item in its Model.
//
// The function returns the following values:
//
//    - gint: index of the selected item, or -1 if no item is selected.
//
func (self *ComboRow) SelectedIndex() int {
	var _arg0 *C.HdyComboRow // out
	var _cret C.gint         // in

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_combo_row_get_selected_index(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UseSubtitle gets whether the current value of self should be displayed as its
// subtitle.
//
// The function returns the following values:
//
//    - ok: whether the current value of self should be displayed as its
//      subtitle.
//
func (self *ComboRow) UseSubtitle() bool {
	var _arg0 *C.HdyComboRow // out
	var _cret C.gboolean     // in

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_combo_row_get_use_subtitle(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetForEnum creates a model for enum_type and binds it to self. The items of
// the model will be EnumValueObject objects.
//
// If self was already bound to a model, that previous binding is destroyed.
//
// The contents of self are cleared and then filled with widgets that represent
// items from model. self is updated whenever model changes. If model is NULL,
// self is left empty.
//
// This is more convenient to use than hdy_combo_row_bind_name_model() if you
// want to represent values of an enumeration with names.
//
// See hdy_enum_value_row_name().
//
// The function takes the following parameters:
//
//    - enumType: enumeration #GType to be bound to self.
//    - getNameFunc (optional): function that creates names for items, or NULL in
//      case you also passed NULL as model.
//
func (self *ComboRow) SetForEnum(enumType externglib.Type, getNameFunc ComboRowGetEnumValueNameFunc) {
	var _arg0 *C.HdyComboRow                    // out
	var _arg1 C.GType                           // out
	var _arg2 C.HdyComboRowGetEnumValueNameFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.GType(enumType)
	if getNameFunc != nil {
		_arg2 = (*[0]byte)(C._gotk4_handy1_ComboRowGetEnumValueNameFunc)
		_arg3 = C.gpointer(gbox.Assign(getNameFunc))
		_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.hdy_combo_row_set_for_enum(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(enumType)
	runtime.KeepAlive(getNameFunc)
}

// SetGetNameFunc sets a closure to convert items into names. See
// HdyComboRow:use-subtitle.
//
// The function takes the following parameters:
//
//    - getNameFunc (optional): function that creates names for items, or NULL in
//      case you also passed NULL as model.
//
func (self *ComboRow) SetGetNameFunc(getNameFunc ComboRowGetNameFunc) {
	var _arg0 *C.HdyComboRow           // out
	var _arg1 C.HdyComboRowGetNameFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if getNameFunc != nil {
		_arg1 = (*[0]byte)(C._gotk4_handy1_ComboRowGetNameFunc)
		_arg2 = C.gpointer(gbox.Assign(getNameFunc))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.hdy_combo_row_set_get_name_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(getNameFunc)
}

// SetSelectedIndex sets the index of the selected item in its Model.
//
// The function takes the following parameters:
//
//    - selectedIndex: index of the selected item.
//
func (self *ComboRow) SetSelectedIndex(selectedIndex int) {
	var _arg0 *C.HdyComboRow // out
	var _arg1 C.gint         // out

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.gint(selectedIndex)

	C.hdy_combo_row_set_selected_index(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(selectedIndex)
}

// SetUseSubtitle sets whether the current value of self should be displayed as
// its subtitle.
//
// If TRUE, you should not access HdyActionRow:subtitle.
//
// The function takes the following parameters:
//
//    - useSubtitle: TRUE to set the current value as the subtitle.
//
func (self *ComboRow) SetUseSubtitle(useSubtitle bool) {
	var _arg0 *C.HdyComboRow // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if useSubtitle {
		_arg1 = C.TRUE
	}

	C.hdy_combo_row_set_use_subtitle(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(useSubtitle)
}
