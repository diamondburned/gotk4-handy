// Code generated by girgen. DO NOT EDIT.

package handy

import (
	"runtime"
	"runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #cgo pkg-config: libhandy-1
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <handy.h>
// GtkWidget* _gotk4_gtk3_ListBoxCreateWidgetFunc(gpointer, gpointer);
// extern void callbackDelete(gpointer);
// gchar* _gotk4_handy1_ComboRowGetEnumValueNameFunc(HdyEnumValueObject*, gpointer);
// gchar* _gotk4_handy1_ComboRowGetNameFunc(gpointer, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.hdy_combo_row_get_type()), F: marshalComboRower},
	})
}

// ComboRowGetEnumValueNameFunc: called for combo rows that are bound to an
// enumeration with hdy_combo_row_set_for_enum() for each value from that
// enumeration.
type ComboRowGetEnumValueNameFunc func(value *EnumValueObject) (utf8 string)

//export _gotk4_handy1_ComboRowGetEnumValueNameFunc
func _gotk4_handy1_ComboRowGetEnumValueNameFunc(arg0 *C.HdyEnumValueObject, arg1 C.gpointer) (cret *C.gchar) {
	v := gbox.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var value *EnumValueObject // out

	value = wrapEnumValueObject(externglib.Take(unsafe.Pointer(arg0)))

	fn := v.(ComboRowGetEnumValueNameFunc)
	utf8 := fn(value)

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

// ComboRowGetNameFunc: called for combo rows that are bound to a Model with
// hdy_combo_row_bind_name_model() for each item that gets added to the model.
type ComboRowGetNameFunc func(item *externglib.Object) (utf8 string)

//export _gotk4_handy1_ComboRowGetNameFunc
func _gotk4_handy1_ComboRowGetNameFunc(arg0 C.gpointer, arg1 C.gpointer) (cret *C.gchar) {
	v := gbox.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var item *externglib.Object // out

	item = externglib.Take(unsafe.Pointer(arg0))

	fn := v.(ComboRowGetNameFunc)
	utf8 := fn(item)

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

// EnumValueRowName: this is a default implementation of
// ComboRowGetEnumValueNameFunc to be used with hdy_combo_row_set_for_enum(). If
// the enumeration has a nickname, it will return it, otherwise it will return
// its name.
//
// The function takes the following parameters:
//
//    - value from the enum from which to get a name.
//    - userData: unused user data.
//
func EnumValueRowName(value *EnumValueObject, userData cgo.Handle) string {
	var _arg1 *C.HdyEnumValueObject // out
	var _arg2 C.gpointer            // out
	var _cret *C.gchar              // in

	_arg1 = (*C.HdyEnumValueObject)(unsafe.Pointer(value.Native()))
	_arg2 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.hdy_enum_value_row_name(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(userData)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

type ComboRow struct {
	ActionRow
}

func wrapComboRow(obj *externglib.Object) *ComboRow {
	return &ComboRow{
		ActionRow: ActionRow{
			PreferencesRow: PreferencesRow{
				ListBoxRow: gtk.ListBoxRow{
					Bin: gtk.Bin{
						Container: gtk.Container{
							Widget: gtk.Widget{
								InitiallyUnowned: externglib.InitiallyUnowned{
									Object: obj,
								},
								ImplementorIface: atk.ImplementorIface{
									Object: obj,
								},
								Buildable: gtk.Buildable{
									Object: obj,
								},
								Object: obj,
							},
						},
					},
					Actionable: gtk.Actionable{
						Widget: gtk.Widget{
							InitiallyUnowned: externglib.InitiallyUnowned{
								Object: obj,
							},
							ImplementorIface: atk.ImplementorIface{
								Object: obj,
							},
							Buildable: gtk.Buildable{
								Object: obj,
							},
							Object: obj,
						},
					},
					Object: obj,
				},
			},
		},
	}
}

func marshalComboRower(p uintptr) (interface{}, error) {
	return wrapComboRow(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewComboRow creates a new ComboRow.
func NewComboRow() *ComboRow {
	var _cret *C.GtkWidget // in

	_cret = C.hdy_combo_row_new()

	var _comboRow *ComboRow // out

	_comboRow = wrapComboRow(externglib.Take(unsafe.Pointer(_cret)))

	return _comboRow
}

// BindModel binds model to self.
//
// If self was already bound to a model, that previous binding is destroyed.
//
// The contents of self are cleared and then filled with widgets that represent
// items from model. self is updated whenever model changes. If model is NULL,
// self is left empty.
//
// The function takes the following parameters:
//
//    - model to be bound to self.
//    - createListWidgetFunc: function that creates widgets for items to
//    display in the list, or NULL in case you also passed NULL as model.
//    - createCurrentWidgetFunc: function that creates widgets for items to
//    display as the selected item, or NULL in case you also passed NULL as
//    model.
//
func (self *ComboRow) BindModel(model gio.ListModeller, createListWidgetFunc, createCurrentWidgetFunc gtk.ListBoxCreateWidgetFunc) {
	var _arg0 *C.HdyComboRow               // out
	var _arg1 *C.GListModel                // out
	var _arg2 C.GtkListBoxCreateWidgetFunc // out
	var _arg3 C.GtkListBoxCreateWidgetFunc // out
	var _arg4 C.gpointer
	var _arg5 C.GDestroyNotify

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(self.Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))
	}
	if createListWidgetFunc != nil {
	}
	if createCurrentWidgetFunc != nil {
		_arg3 = (*[0]byte)(C._gotk4_gtk3_ListBoxCreateWidgetFunc)
		_arg4 = C.gpointer(gbox.Assign(createCurrentWidgetFunc))
		_arg5 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.hdy_combo_row_bind_model(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
	runtime.KeepAlive(createListWidgetFunc)
	runtime.KeepAlive(createCurrentWidgetFunc)
}

// BindNameModel binds model to self.
//
// If self was already bound to a model, that previous binding is destroyed.
//
// The contents of self are cleared and then filled with widgets that represent
// items from model. self is updated whenever model changes. If model is NULL,
// self is left empty.
//
// This is more convenient to use than hdy_combo_row_bind_model() if you want to
// represent items of the model with names.
//
// The function takes the following parameters:
//
//    - model to be bound to self.
//    - getNameFunc: function that creates names for items, or NULL in case you
//    also passed NULL as model.
//
func (self *ComboRow) BindNameModel(model gio.ListModeller, getNameFunc ComboRowGetNameFunc) {
	var _arg0 *C.HdyComboRow           // out
	var _arg1 *C.GListModel            // out
	var _arg2 C.HdyComboRowGetNameFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(self.Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))
	}
	if getNameFunc != nil {
		_arg2 = (*[0]byte)(C._gotk4_handy1_ComboRowGetNameFunc)
		_arg3 = C.gpointer(gbox.Assign(getNameFunc))
		_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.hdy_combo_row_bind_name_model(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
	runtime.KeepAlive(getNameFunc)
}

// Model gets the model bound to self, or NULL if none is bound.
func (self *ComboRow) Model() gio.ListModeller {
	var _arg0 *C.HdyComboRow // out
	var _cret *C.GListModel  // in

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_combo_row_get_model(_arg0)
	runtime.KeepAlive(self)

	var _listModel gio.ListModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(gio.ListModeller)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gio.ListModeller")
			}
			_listModel = rv
		}
	}

	return _listModel
}

// SelectedIndex gets the index of the selected item in its Model.
func (self *ComboRow) SelectedIndex() int {
	var _arg0 *C.HdyComboRow // out
	var _cret C.gint         // in

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_combo_row_get_selected_index(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UseSubtitle gets whether the current value of self should be displayed as its
// subtitle.
func (self *ComboRow) UseSubtitle() bool {
	var _arg0 *C.HdyComboRow // out
	var _cret C.gboolean     // in

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(self.Native()))

	_cret = C.hdy_combo_row_get_use_subtitle(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetForEnum creates a model for enum_type and binds it to self. The items of
// the model will be EnumValueObject objects.
//
// If self was already bound to a model, that previous binding is destroyed.
//
// The contents of self are cleared and then filled with widgets that represent
// items from model. self is updated whenever model changes. If model is NULL,
// self is left empty.
//
// This is more convenient to use than hdy_combo_row_bind_name_model() if you
// want to represent values of an enumeration with names.
//
// See hdy_enum_value_row_name().
//
// The function takes the following parameters:
//
//    - enumType: enumeration #GType to be bound to self.
//    - getNameFunc: function that creates names for items, or NULL in case you
//    also passed NULL as model.
//
func (self *ComboRow) SetForEnum(enumType externglib.Type, getNameFunc ComboRowGetEnumValueNameFunc) {
	var _arg0 *C.HdyComboRow                    // out
	var _arg1 C.GType                           // out
	var _arg2 C.HdyComboRowGetEnumValueNameFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(self.Native()))
	_arg1 = C.GType(enumType)
	if getNameFunc != nil {
		_arg2 = (*[0]byte)(C._gotk4_handy1_ComboRowGetEnumValueNameFunc)
		_arg3 = C.gpointer(gbox.Assign(getNameFunc))
		_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.hdy_combo_row_set_for_enum(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(enumType)
	runtime.KeepAlive(getNameFunc)
}

// SetGetNameFunc sets a closure to convert items into names. See
// HdyComboRow:use-subtitle.
//
// The function takes the following parameters:
//
//    - getNameFunc: function that creates names for items, or NULL in case you
//    also passed NULL as model.
//
func (self *ComboRow) SetGetNameFunc(getNameFunc ComboRowGetNameFunc) {
	var _arg0 *C.HdyComboRow           // out
	var _arg1 C.HdyComboRowGetNameFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(self.Native()))
	if getNameFunc != nil {
		_arg1 = (*[0]byte)(C._gotk4_handy1_ComboRowGetNameFunc)
		_arg2 = C.gpointer(gbox.Assign(getNameFunc))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.hdy_combo_row_set_get_name_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(getNameFunc)
}

// SetSelectedIndex sets the index of the selected item in its Model.
//
// The function takes the following parameters:
//
//    - selectedIndex: index of the selected item.
//
func (self *ComboRow) SetSelectedIndex(selectedIndex int) {
	var _arg0 *C.HdyComboRow // out
	var _arg1 C.gint         // out

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(self.Native()))
	_arg1 = C.gint(selectedIndex)

	C.hdy_combo_row_set_selected_index(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(selectedIndex)
}

// SetUseSubtitle sets whether the current value of self should be displayed as
// its subtitle.
//
// If TRUE, you should not access HdyActionRow:subtitle.
//
// The function takes the following parameters:
//
//    - useSubtitle: TRUE to set the current value as the subtitle.
//
func (self *ComboRow) SetUseSubtitle(useSubtitle bool) {
	var _arg0 *C.HdyComboRow // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.HdyComboRow)(unsafe.Pointer(self.Native()))
	if useSubtitle {
		_arg1 = C.TRUE
	}

	C.hdy_combo_row_set_use_subtitle(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(useSubtitle)
}
