// Code generated by girgen. DO NOT EDIT.

package handy

import (
	"runtime"
	"unsafe"

	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <handy.h>
// extern void _gotk4_handy1_SwipeTracker_ConnectBeginSwipe(gpointer, HdyNavigationDirection, gboolean, guintptr);
// extern void _gotk4_handy1_SwipeTracker_ConnectEndSwipe(gpointer, gint64, gdouble, guintptr);
// extern void _gotk4_handy1_SwipeTracker_ConnectUpdateSwipe(gpointer, gdouble, guintptr);
import "C"

// glib.Type values for hdy-swipe-tracker.go.
var GTypeSwipeTracker = externglib.Type(C.hdy_swipe_tracker_get_type())

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeSwipeTracker, F: marshalSwipeTracker},
	})
}

// SwipeTrackerOverrider contains methods that are overridable.
type SwipeTrackerOverrider interface {
}

type SwipeTracker struct {
	_ [0]func() // equal guard
	*externglib.Object

	gtk.Orientable
}

var (
	_ externglib.Objector = (*SwipeTracker)(nil)
)

func classInitSwipeTrackerer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapSwipeTracker(obj *externglib.Object) *SwipeTracker {
	return &SwipeTracker{
		Object: obj,
		Orientable: gtk.Orientable{
			Object: obj,
		},
	}
}

func marshalSwipeTracker(p uintptr) (interface{}, error) {
	return wrapSwipeTracker(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_handy1_SwipeTracker_ConnectBeginSwipe
func _gotk4_handy1_SwipeTracker_ConnectBeginSwipe(arg0 C.gpointer, arg1 C.HdyNavigationDirection, arg2 C.gboolean, arg3 C.guintptr) {
	var f func(direction NavigationDirection, direct bool)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(direction NavigationDirection, direct bool))
	}

	var _direction NavigationDirection // out
	var _direct bool                   // out

	_direction = NavigationDirection(arg1)
	if arg2 != 0 {
		_direct = true
	}

	f(_direction, _direct)
}

// ConnectBeginSwipe: this signal is emitted when a possible swipe is detected.
//
// The direction value can be used to restrict the swipe to a certain direction.
func (self *SwipeTracker) ConnectBeginSwipe(f func(direction NavigationDirection, direct bool)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "begin-swipe", false, unsafe.Pointer(C._gotk4_handy1_SwipeTracker_ConnectBeginSwipe), f)
}

//export _gotk4_handy1_SwipeTracker_ConnectEndSwipe
func _gotk4_handy1_SwipeTracker_ConnectEndSwipe(arg0 C.gpointer, arg1 C.gint64, arg2 C.gdouble, arg3 C.guintptr) {
	var f func(duration int64, to float64)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(duration int64, to float64))
	}

	var _duration int64 // out
	var _to float64     // out

	_duration = int64(arg1)
	_to = float64(arg2)

	f(_duration, _to)
}

// ConnectEndSwipe: this signal is emitted as soon as the gesture has stopped.
func (self *SwipeTracker) ConnectEndSwipe(f func(duration int64, to float64)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "end-swipe", false, unsafe.Pointer(C._gotk4_handy1_SwipeTracker_ConnectEndSwipe), f)
}

//export _gotk4_handy1_SwipeTracker_ConnectUpdateSwipe
func _gotk4_handy1_SwipeTracker_ConnectUpdateSwipe(arg0 C.gpointer, arg1 C.gdouble, arg2 C.guintptr) {
	var f func(progress float64)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(progress float64))
	}

	var _progress float64 // out

	_progress = float64(arg1)

	f(_progress)
}

// ConnectUpdateSwipe: this signal is emitted every time the progress value
// changes.
func (self *SwipeTracker) ConnectUpdateSwipe(f func(progress float64)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "update-swipe", false, unsafe.Pointer(C._gotk4_handy1_SwipeTracker_ConnectUpdateSwipe), f)
}

// NewSwipeTracker: create a new SwipeTracker object on widget.
//
// The function takes the following parameters:
//
//    - swipeable to add the tracker on.
//
// The function returns the following values:
//
//    - swipeTracker: newly created SwipeTracker object.
//
func NewSwipeTracker(swipeable Swipeabler) *SwipeTracker {
	var _arg1 *C.HdySwipeable    // out
	var _cret *C.HdySwipeTracker // in

	_arg1 = (*C.HdySwipeable)(unsafe.Pointer(externglib.InternObject(swipeable).Native()))

	_cret = C.hdy_swipe_tracker_new(_arg1)
	runtime.KeepAlive(swipeable)

	var _swipeTracker *SwipeTracker // out

	_swipeTracker = wrapSwipeTracker(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _swipeTracker
}

// AllowLongSwipes: whether to allow swiping for more than one snap point at a
// time. If the value is FALSE, each swipe can only move to the adjacent snap
// points.
//
// The function returns the following values:
//
//    - ok: TRUE if long swipes are allowed, FALSE otherwise.
//
func (self *SwipeTracker) AllowLongSwipes() bool {
	var _arg0 *C.HdySwipeTracker // out
	var _cret C.gboolean         // in

	_arg0 = (*C.HdySwipeTracker)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_swipe_tracker_get_allow_long_swipes(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AllowMouseDrag: get whether self can be dragged with mouse pointer.
//
// The function returns the following values:
//
//    - ok: TRUE is mouse dragging is allowed.
//
func (self *SwipeTracker) AllowMouseDrag() bool {
	var _arg0 *C.HdySwipeTracker // out
	var _cret C.gboolean         // in

	_arg0 = (*C.HdySwipeTracker)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_swipe_tracker_get_allow_mouse_drag(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Enabled: get whether self is enabled. When it's not enabled, no events will
// be processed. Generally widgets will want to expose this via a property.
//
// The function returns the following values:
//
//    - ok: TRUE if self is enabled.
//
func (self *SwipeTracker) Enabled() bool {
	var _arg0 *C.HdySwipeTracker // out
	var _cret C.gboolean         // in

	_arg0 = (*C.HdySwipeTracker)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_swipe_tracker_get_enabled(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Reversed: get whether self is reversing the swipe direction.
//
// The function returns the following values:
//
//    - ok: TRUE is the direction is reversed.
//
func (self *SwipeTracker) Reversed() bool {
	var _arg0 *C.HdySwipeTracker // out
	var _cret C.gboolean         // in

	_arg0 = (*C.HdySwipeTracker)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_swipe_tracker_get_reversed(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Swipeable: get self's swipeable widget.
//
// The function returns the following values:
//
//    - swipeable widget.
//
func (self *SwipeTracker) Swipeable() Swipeabler {
	var _arg0 *C.HdySwipeTracker // out
	var _cret *C.HdySwipeable    // in

	_arg0 = (*C.HdySwipeTracker)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_swipe_tracker_get_swipeable(_arg0)
	runtime.KeepAlive(self)

	var _swipeable Swipeabler // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type handy.Swipeabler is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(Swipeabler)
			return ok
		})
		rv, ok := casted.(Swipeabler)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching handy.Swipeabler")
		}
		_swipeable = rv
	}

	return _swipeable
}

// SetAllowLongSwipes sets whether to allow swiping for more than one snap point
// at a time. If the value is FALSE, each swipe can only move to the adjacent
// snap points.
//
// The function takes the following parameters:
//
//    - allowLongSwipes: whether to allow long swipes.
//
func (self *SwipeTracker) SetAllowLongSwipes(allowLongSwipes bool) {
	var _arg0 *C.HdySwipeTracker // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.HdySwipeTracker)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if allowLongSwipes {
		_arg1 = C.TRUE
	}

	C.hdy_swipe_tracker_set_allow_long_swipes(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(allowLongSwipes)
}

// SetAllowMouseDrag: set whether self can be dragged with mouse pointer. This
// should usually be FALSE.
//
// The function takes the following parameters:
//
//    - allowMouseDrag: whether to allow mouse dragging.
//
func (self *SwipeTracker) SetAllowMouseDrag(allowMouseDrag bool) {
	var _arg0 *C.HdySwipeTracker // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.HdySwipeTracker)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if allowMouseDrag {
		_arg1 = C.TRUE
	}

	C.hdy_swipe_tracker_set_allow_mouse_drag(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(allowMouseDrag)
}

// SetEnabled: set whether self is enabled. When it's not enabled, no events
// will be processed. Usually widgets will want to expose this via a property.
//
// The function takes the following parameters:
//
//    - enabled: whether to enable to swipe tracker.
//
func (self *SwipeTracker) SetEnabled(enabled bool) {
	var _arg0 *C.HdySwipeTracker // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.HdySwipeTracker)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.hdy_swipe_tracker_set_enabled(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(enabled)
}

// SetReversed: set whether to reverse the swipe direction. If self is
// horizontal, can be used for supporting RTL text direction.
//
// The function takes the following parameters:
//
//    - reversed: whether to reverse the swipe direction.
//
func (self *SwipeTracker) SetReversed(reversed bool) {
	var _arg0 *C.HdySwipeTracker // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.HdySwipeTracker)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if reversed {
		_arg1 = C.TRUE
	}

	C.hdy_swipe_tracker_set_reversed(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(reversed)
}

// ShiftPosition: move the current progress value by delta. This can be used to
// adjust the current position if snap points move during the gesture.
//
// The function takes the following parameters:
//
//    - delta: position delta.
//
func (self *SwipeTracker) ShiftPosition(delta float64) {
	var _arg0 *C.HdySwipeTracker // out
	var _arg1 C.gdouble          // out

	_arg0 = (*C.HdySwipeTracker)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.gdouble(delta)

	C.hdy_swipe_tracker_shift_position(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(delta)
}
