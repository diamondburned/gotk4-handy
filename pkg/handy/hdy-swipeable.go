// Code generated by girgen. DO NOT EDIT.

package handy

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <handy.h>
// extern HdySwipeTracker* _gotk4_handy1_SwipeableInterface_get_swipe_tracker(HdySwipeable*);
// extern gdouble _gotk4_handy1_SwipeableInterface_get_cancel_progress(HdySwipeable*);
// extern gdouble _gotk4_handy1_SwipeableInterface_get_distance(HdySwipeable*);
// extern gdouble _gotk4_handy1_SwipeableInterface_get_progress(HdySwipeable*);
// extern gdouble* _gotk4_handy1_SwipeableInterface_get_snap_points(HdySwipeable*, gint*);
// extern void _gotk4_handy1_SwipeableInterface_get_swipe_area(HdySwipeable*, HdyNavigationDirection, gboolean, GdkRectangle*);
// extern void _gotk4_handy1_SwipeableInterface_switch_child(HdySwipeable*, guint, gint64);
// extern void _gotk4_handy1_Swipeable_ConnectChildSwitched(gpointer, guint, gint64, guintptr);
import "C"

// glib.Type values for hdy-swipeable.go.
var GTypeSwipeable = externglib.Type(C.hdy_swipeable_get_type())

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeSwipeable, F: marshalSwipeable},
	})
}

// SwipeableOverrider contains methods that are overridable.
type SwipeableOverrider interface {
	// CancelProgress gets the progress self will snap back to after the gesture
	// is canceled.
	//
	// The function returns the following values:
	//
	//    - gdouble: cancel progress, unitless.
	//
	CancelProgress() float64
	// Distance gets the swipe distance of self. This corresponds to how many
	// pixels 1 unit represents.
	//
	// The function returns the following values:
	//
	//    - gdouble: swipe distance in pixels.
	//
	Distance() float64
	// Progress gets the current progress of self.
	//
	// The function returns the following values:
	//
	//    - gdouble: current progress, unitless.
	//
	Progress() float64
	// SnapPoints gets the snap points of self. Each snap point represents a
	// progress value that is considered acceptable to end the swipe on.
	//
	// The function returns the following values:
	//
	//    - gdoubles: snap points of self. The array must be freed with g_free().
	//
	SnapPoints() []float64
	// SwipeArea gets the area self can start a swipe from for the given
	// direction and gesture type. This can be used to restrict swipes to only
	// be possible from a certain area, for example, to only allow edge swipes,
	// or to have a draggable element and ignore swipes elsewhere.
	//
	// Swipe area is only considered for direct swipes (as in, not initiated by
	// SwipeGroup).
	//
	// If not implemented, the default implementation returns the allocation of
	// self, allowing swipes from anywhere.
	//
	// The function takes the following parameters:
	//
	//    - navigationDirection: direction of the swipe.
	//    - isDrag: whether the swipe is caused by a dragging gesture.
	//
	// The function returns the following values:
	//
	//    - rect: pointer to a Rectangle to store the swipe area.
	//
	SwipeArea(navigationDirection NavigationDirection, isDrag bool) *gdk.Rectangle
	// SwipeTracker gets the SwipeTracker used by this swipeable widget.
	//
	// The function returns the following values:
	//
	//    - swipeTracker: swipe tracker.
	//
	SwipeTracker() *SwipeTracker
	// SwitchChild: see HdySwipeable::child-switched.
	//
	// The function takes the following parameters:
	//
	//    - index of the child to switch to.
	//    - duration: animation duration in milliseconds.
	//
	SwitchChild(index uint, duration int64)
}

//
// Swipeable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Swipeable struct {
	_ [0]func() // equal guard
	gtk.Widget
}

var (
	_ gtk.Widgetter = (*Swipeable)(nil)
)

// Swipeabler describes Swipeable's interface methods.
type Swipeabler interface {
	externglib.Objector

	// EmitChildSwitched emits HdySwipeable::child-switched signal.
	EmitChildSwitched(index uint, duration int64)
	// CancelProgress gets the progress self will snap back to after the gesture
	// is canceled.
	CancelProgress() float64
	// Distance gets the swipe distance of self.
	Distance() float64
	// Progress gets the current progress of self.
	Progress() float64
	// SnapPoints gets the snap points of self.
	SnapPoints() []float64
	// SwipeArea gets the area self can start a swipe from for the given
	// direction and gesture type.
	SwipeArea(navigationDirection NavigationDirection, isDrag bool) *gdk.Rectangle
	// SwipeTracker gets the SwipeTracker used by this swipeable widget.
	SwipeTracker() *SwipeTracker
	// SwitchChild: see HdySwipeable::child-switched.
	SwitchChild(index uint, duration int64)

	// Child-switched: this signal should be emitted when the widget's visible
	// child is changed.
	ConnectChildSwitched(func(index uint, duration int64)) externglib.SignalHandle
}

var _ Swipeabler = (*Swipeable)(nil)

func ifaceInitSwipeabler(gifacePtr, data C.gpointer) {
	iface := (*C.HdySwipeableInterface)(unsafe.Pointer(gifacePtr))
	iface.get_cancel_progress = (*[0]byte)(C._gotk4_handy1_SwipeableInterface_get_cancel_progress)
	iface.get_distance = (*[0]byte)(C._gotk4_handy1_SwipeableInterface_get_distance)
	iface.get_progress = (*[0]byte)(C._gotk4_handy1_SwipeableInterface_get_progress)
	iface.get_snap_points = (*[0]byte)(C._gotk4_handy1_SwipeableInterface_get_snap_points)
	iface.get_swipe_area = (*[0]byte)(C._gotk4_handy1_SwipeableInterface_get_swipe_area)
	iface.get_swipe_tracker = (*[0]byte)(C._gotk4_handy1_SwipeableInterface_get_swipe_tracker)
	iface.switch_child = (*[0]byte)(C._gotk4_handy1_SwipeableInterface_switch_child)
}

//export _gotk4_handy1_SwipeableInterface_get_cancel_progress
func _gotk4_handy1_SwipeableInterface_get_cancel_progress(arg0 *C.HdySwipeable) (cret C.gdouble) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SwipeableOverrider)

	gdouble := iface.CancelProgress()

	cret = C.gdouble(gdouble)

	return cret
}

//export _gotk4_handy1_SwipeableInterface_get_distance
func _gotk4_handy1_SwipeableInterface_get_distance(arg0 *C.HdySwipeable) (cret C.gdouble) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SwipeableOverrider)

	gdouble := iface.Distance()

	cret = C.gdouble(gdouble)

	return cret
}

//export _gotk4_handy1_SwipeableInterface_get_progress
func _gotk4_handy1_SwipeableInterface_get_progress(arg0 *C.HdySwipeable) (cret C.gdouble) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SwipeableOverrider)

	gdouble := iface.Progress()

	cret = C.gdouble(gdouble)

	return cret
}

//export _gotk4_handy1_SwipeableInterface_get_snap_points
func _gotk4_handy1_SwipeableInterface_get_snap_points(arg0 *C.HdySwipeable, arg1 *C.gint) (cret *C.gdouble) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SwipeableOverrider)

	gdoubles := iface.SnapPoints()

	*arg1 = (C.gint)(len(gdoubles))
	cret = (*C.gdouble)(C.calloc(C.size_t(len(gdoubles)), C.size_t(C.sizeof_gdouble)))
	copy(unsafe.Slice((*float64)(cret), len(gdoubles)), gdoubles)

	return cret
}

//export _gotk4_handy1_SwipeableInterface_get_swipe_area
func _gotk4_handy1_SwipeableInterface_get_swipe_area(arg0 *C.HdySwipeable, arg1 C.HdyNavigationDirection, arg2 C.gboolean, arg3 *C.GdkRectangle) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SwipeableOverrider)

	var _navigationDirection NavigationDirection // out
	var _isDrag bool                             // out

	_navigationDirection = NavigationDirection(arg1)
	if arg2 != 0 {
		_isDrag = true
	}

	rect := iface.SwipeArea(_navigationDirection, _isDrag)

	*arg3 = *(*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(rect)))
}

//export _gotk4_handy1_SwipeableInterface_get_swipe_tracker
func _gotk4_handy1_SwipeableInterface_get_swipe_tracker(arg0 *C.HdySwipeable) (cret *C.HdySwipeTracker) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SwipeableOverrider)

	swipeTracker := iface.SwipeTracker()

	cret = (*C.HdySwipeTracker)(unsafe.Pointer(externglib.InternObject(swipeTracker).Native()))

	return cret
}

//export _gotk4_handy1_SwipeableInterface_switch_child
func _gotk4_handy1_SwipeableInterface_switch_child(arg0 *C.HdySwipeable, arg1 C.guint, arg2 C.gint64) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SwipeableOverrider)

	var _index uint     // out
	var _duration int64 // out

	_index = uint(arg1)
	_duration = int64(arg2)

	iface.SwitchChild(_index, _duration)
}

func wrapSwipeable(obj *externglib.Object) *Swipeable {
	return &Swipeable{
		Widget: gtk.Widget{
			InitiallyUnowned: externglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			ImplementorIface: atk.ImplementorIface{
				Object: obj,
			},
			Buildable: gtk.Buildable{
				Object: obj,
			},
		},
	}
}

func marshalSwipeable(p uintptr) (interface{}, error) {
	return wrapSwipeable(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_handy1_Swipeable_ConnectChildSwitched
func _gotk4_handy1_Swipeable_ConnectChildSwitched(arg0 C.gpointer, arg1 C.guint, arg2 C.gint64, arg3 C.guintptr) {
	var f func(index uint, duration int64)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(index uint, duration int64))
	}

	var _index uint     // out
	var _duration int64 // out

	_index = uint(arg1)
	_duration = int64(arg2)

	f(_index, _duration)
}

// ConnectChildSwitched: this signal should be emitted when the widget's visible
// child is changed.
//
// duration can be 0 if the child is switched without animation.
//
// This is used by SwipeGroup, applications should not connect to it.
func (self *Swipeable) ConnectChildSwitched(f func(index uint, duration int64)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "child-switched", false, unsafe.Pointer(C._gotk4_handy1_Swipeable_ConnectChildSwitched), f)
}

// EmitChildSwitched emits HdySwipeable::child-switched signal. This should be
// called when the widget switches visible child widget.
//
// duration can be 0 if the child is switched without animation.
//
// The function takes the following parameters:
//
//    - index of the child to switch to.
//    - duration: animation duration in milliseconds.
//
func (self *Swipeable) EmitChildSwitched(index uint, duration int64) {
	var _arg0 *C.HdySwipeable // out
	var _arg1 C.guint         // out
	var _arg2 C.gint64        // out

	_arg0 = (*C.HdySwipeable)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.guint(index)
	_arg2 = C.gint64(duration)

	C.hdy_swipeable_emit_child_switched(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(index)
	runtime.KeepAlive(duration)
}

// CancelProgress gets the progress self will snap back to after the gesture is
// canceled.
//
// The function returns the following values:
//
//    - gdouble: cancel progress, unitless.
//
func (self *Swipeable) CancelProgress() float64 {
	var _arg0 *C.HdySwipeable // out
	var _cret C.gdouble       // in

	_arg0 = (*C.HdySwipeable)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_swipeable_get_cancel_progress(_arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Distance gets the swipe distance of self. This corresponds to how many pixels
// 1 unit represents.
//
// The function returns the following values:
//
//    - gdouble: swipe distance in pixels.
//
func (self *Swipeable) Distance() float64 {
	var _arg0 *C.HdySwipeable // out
	var _cret C.gdouble       // in

	_arg0 = (*C.HdySwipeable)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_swipeable_get_distance(_arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Progress gets the current progress of self.
//
// The function returns the following values:
//
//    - gdouble: current progress, unitless.
//
func (self *Swipeable) Progress() float64 {
	var _arg0 *C.HdySwipeable // out
	var _cret C.gdouble       // in

	_arg0 = (*C.HdySwipeable)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_swipeable_get_progress(_arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// SnapPoints gets the snap points of self. Each snap point represents a
// progress value that is considered acceptable to end the swipe on.
//
// The function returns the following values:
//
//    - gdoubles: snap points of self. The array must be freed with g_free().
//
func (self *Swipeable) SnapPoints() []float64 {
	var _arg0 *C.HdySwipeable // out
	var _cret *C.gdouble      // in
	var _arg1 C.gint          // in

	_arg0 = (*C.HdySwipeable)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_swipeable_get_snap_points(_arg0, &_arg1)
	runtime.KeepAlive(self)

	var _gdoubles []float64 // out

	defer C.free(unsafe.Pointer(_cret))
	_gdoubles = make([]float64, _arg1)
	copy(_gdoubles, unsafe.Slice((*float64)(unsafe.Pointer(_cret)), _arg1))

	return _gdoubles
}

// SwipeArea gets the area self can start a swipe from for the given direction
// and gesture type. This can be used to restrict swipes to only be possible
// from a certain area, for example, to only allow edge swipes, or to have a
// draggable element and ignore swipes elsewhere.
//
// Swipe area is only considered for direct swipes (as in, not initiated by
// SwipeGroup).
//
// If not implemented, the default implementation returns the allocation of
// self, allowing swipes from anywhere.
//
// The function takes the following parameters:
//
//    - navigationDirection: direction of the swipe.
//    - isDrag: whether the swipe is caused by a dragging gesture.
//
// The function returns the following values:
//
//    - rect: pointer to a Rectangle to store the swipe area.
//
func (self *Swipeable) SwipeArea(navigationDirection NavigationDirection, isDrag bool) *gdk.Rectangle {
	var _arg0 *C.HdySwipeable          // out
	var _arg1 C.HdyNavigationDirection // out
	var _arg2 C.gboolean               // out
	var _arg3 C.GdkRectangle           // in

	_arg0 = (*C.HdySwipeable)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.HdyNavigationDirection(navigationDirection)
	if isDrag {
		_arg2 = C.TRUE
	}

	C.hdy_swipeable_get_swipe_area(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(navigationDirection)
	runtime.KeepAlive(isDrag)

	var _rect *gdk.Rectangle // out

	_rect = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _rect
}

// SwipeTracker gets the SwipeTracker used by this swipeable widget.
//
// The function returns the following values:
//
//    - swipeTracker: swipe tracker.
//
func (self *Swipeable) SwipeTracker() *SwipeTracker {
	var _arg0 *C.HdySwipeable    // out
	var _cret *C.HdySwipeTracker // in

	_arg0 = (*C.HdySwipeable)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.hdy_swipeable_get_swipe_tracker(_arg0)
	runtime.KeepAlive(self)

	var _swipeTracker *SwipeTracker // out

	_swipeTracker = wrapSwipeTracker(externglib.Take(unsafe.Pointer(_cret)))

	return _swipeTracker
}

// SwitchChild: see HdySwipeable::child-switched.
//
// The function takes the following parameters:
//
//    - index of the child to switch to.
//    - duration: animation duration in milliseconds.
//
func (self *Swipeable) SwitchChild(index uint, duration int64) {
	var _arg0 *C.HdySwipeable // out
	var _arg1 C.guint         // out
	var _arg2 C.gint64        // out

	_arg0 = (*C.HdySwipeable)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.guint(index)
	_arg2 = C.gint64(duration)

	C.hdy_swipeable_switch_child(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(index)
	runtime.KeepAlive(duration)
}
